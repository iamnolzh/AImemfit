__DESC__ = "检测目录列表泄露漏洞"
__VERBOSE_NAME__ = "目录列表检测"
__KEYWORDS__ = "directory-listing,information-disclosure"

// 配置项
debug = false

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id", 
    cli.setVerboseName("HTTPFlowID"), 
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"), 
    cli.setRequired(true), 
)
cli.check()

// 辅助输出函数
aiOut = msg => { 
    try {
        yakit.AIOutput(msg) 
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构
// -------------------------------------------------------------------

// 目录列表特征
dirListKeywords = [
    "Index of",
    "Directory Listing",
    "Parent Directory",
    "目录列表",
    "<title>Index of",
]

// 常见目录
testDirs = [
    "/",
    "/backup/",
    "/admin/",
    "/uploads/",
    "/files/",
    "/images/",
    "/static/",
]

// -------------------------------------------------------------------
// 核心逻辑
// -------------------------------------------------------------------

// 检查目录列表
checkDirListing = func(responseRaw) {
    if responseRaw == nil { return "" }
    
    r = string(responseRaw)
    
    // 检查HTTP状态码
    if !str.Contains(r, "HTTP/1.1 200") && !str.Contains(r, "HTTP/1.0 200") {
        return ""
    }
    
    // 检查目录列表特征
    for _, keyword = range dirListKeywords {
        if str.Contains(r, keyword) {
            return keyword
        }
    }
    
    return ""
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始目录列表检测 (Target: %s)...", flow.Url))

// 遍历测试目录
findings = []
for _, testPath = range testDirs {
    fuzzReq = freq.FuzzPath(testPath)
    res, err = fuzzReq.ExecFirst()
    
    if err != nil {
        if debug { aiOut(sprintf("请求失败 (%s): %v", testPath, err)) }
        continue
    }
    
    if res == nil { continue }
    
    // 检查目录列表
    keyword = checkDirListing(res.ResponseRaw)
    if keyword != "" {
        findings = append(findings, {"path": testPath, "keyword": keyword})
        aiOut(sprintf("✓ 发现目录列表: %s (特征: %s)", testPath, keyword))
        
        risk.NewRisk(
            flow.Url + testPath,
            risk.title(sprintf("Directory Listing Enabled: %s", testPath)),
            risk.titleVerbose(sprintf("目录列表泄露: %s", testPath)),
            risk.details({"path": testPath, "keyword": keyword, "url": flow.Url}),
            risk.type("directory-listing"),
            risk.severity("medium"),
            risk.payload(testPath),
            risk.request(res.RequestRaw),
            risk.response(res.ResponseRaw),
            risk.description(sprintf("目录 %s 启用了目录列表功能，可能泄露文件结构。", testPath)),
            risk.solution("1. 禁用Web服务器的目录列表功能。\n2. 在目录中放置 index.html 文件。")
        )
    }
}

if len(findings) == 0 {
    aiOut("未发现目录列表问题")
}

aiOut(sprintf("=== 目录列表检测完成, 发现 %d 个问题 ===", len(findings)))
