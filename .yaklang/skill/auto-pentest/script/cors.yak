__DESC__ = "检测CORS跨域资源共享配置错误漏洞"
__VERBOSE_NAME__ = "CORS配置检测"
__KEYWORDS__ = "cors,cross-origin,access-control"

// 配置项
debug = false

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id", 
    cli.setVerboseName("HTTPFlowID"), 
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"), 
    cli.setRequired(true), 
)
cli.check()

// 辅助输出函数
aiOut = msg => { 
    try {
        yakit.AIOutput(msg) 
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构
// -------------------------------------------------------------------

// 测试Origin列表
testOrigins = [
    "https://evil.com",
    "https://attacker.com", 
    "null",
    "http://evil.com",
]

// -------------------------------------------------------------------
// 核心逻辑
// -------------------------------------------------------------------

// 检查CORS响应头
checkCORS = func(responseRaw, testOrigin) {
    if responseRaw == nil { return false }
    
    r = string(responseRaw)
    
    // 检查是否包含 Access-Control-Allow-Origin
    if !str.Contains(r, "Access-Control-Allow-Origin") {
        return false
    }
    
    // 检查是否反射了恶意Origin或使用了通配符
    if str.Contains(r, testOrigin) || str.Contains(r, "Access-Control-Allow-Origin: *") {
        return true
    }
    
    return false
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始CORS配置检测 (Target: %s)...", flow.Url))

// 遍历测试Origin
findings = []
for _, testOrigin = range testOrigins {
    // 添加Origin头
    fuzzReq = freq.FuzzHTTPHeader("Origin", testOrigin)
    
    res, err = fuzzReq.ExecFirst()
    if err != nil {
        if debug { aiOut(sprintf("请求失败 (Origin: %s): %v", testOrigin, err)) }
        continue
    }
    
    if res == nil { continue }
    
    // 检查CORS配置
    if checkCORS(res.ResponseRaw, testOrigin) {
        findings = append(findings, {"origin": testOrigin, "evidence": "CORS配置错误"})
        aiOut(sprintf("✓ 发现CORS配置错误: Origin=%s 被接受", testOrigin))
        
        // 创建风险项
        risk.NewRisk(
            flow.Url,
            risk.title(sprintf("CORS Configuration Error: %s", flow.Url)),
            risk.titleVerbose(sprintf("CORS跨域配置错误: %s", flow.Url)),
            risk.details({"origin": testOrigin, "url": flow.Url}),
            risk.type("cors-misconfiguration"),
            risk.severity("medium"),
            risk.payload(testOrigin),
            risk.request(res.RequestRaw),
            risk.response(res.ResponseRaw),
            risk.description(sprintf("服务器接受了来自恶意域名 %s 的跨域请求，可能导致CSRF攻击。", testOrigin)),
            risk.solution("1. 严格限制 Access-Control-Allow-Origin，避免使用通配符 *。\n2. 验证 Origin 头，只允许可信域名。\n3. 避免直接反射客户端提供的 Origin 值。")
        )
    }
}

if len(findings) == 0 {
    aiOut("未发现CORS配置问题")
}

aiOut(sprintf("=== CORS检测完成, 发现 %d 个问题 ===", len(findings)))
