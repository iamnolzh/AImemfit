__DESC__ = "检测CSRF跨站请求伪造漏洞"
__VERBOSE_NAME__ = "CSRF检测"
__KEYWORDS__ = "csrf,cross-site-request-forgery"

// 配置项
debug = false

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id", 
    cli.setVerboseName("HTTPFlowID"), 
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"), 
    cli.setRequired(true), 
)
cli.check()

// 辅助输出函数
aiOut = msg => { 
    try {
        yakit.AIOutput(msg) 
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构
// -------------------------------------------------------------------

// CSRF Token参数名
csrfTokenNames = [
    "csrf",
    "csrf_token",
    "_csrf",
    "token",
    "authenticity_token",
    "_token",
]

// -------------------------------------------------------------------
// 核心逻辑
// -------------------------------------------------------------------

// 检查CSRF保护
checkCSRF = func(requestRaw) {
    if requestRaw == nil { return false }
    
    r = string(requestRaw)
    
    // 检查是否有CSRF Token
    for _, tokenName = range csrfTokenNames {
        if str.Contains(str.ToLower(r), str.ToLower(tokenName)) {
            return true
        }
    }
    
    return false
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

// 判断是否为POST请求
if !str.Contains(string(reqBytes), "POST") {
    aiOut("非POST请求,跳过CSRF检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始CSRF检测 (Target: %s)...", flow.Url))

// 检查CSRF保护
hasCSRFProtection = checkCSRF(reqBytes)

if !hasCSRFProtection {
    aiOut("✓ 发现CSRF漏洞: 请求缺少CSRF Token")
    
    // 尝试移除Referer和Origin头重放请求
    fuzzReq = freq.FuzzHTTPHeader("Referer", "").FuzzHTTPHeader("Origin", "")
    res, err = fuzzReq.ExecFirst()
    
    if err == nil && res != nil {
        rsp = string(res.ResponseRaw)
        
        // 检查请求是否成功
        if str.Contains(rsp, "HTTP/1.1 200") || str.Contains(rsp, "success") {
            aiOut("✓ 确认CSRF漏洞: 移除Referer后请求仍成功")
            
            risk.NewRisk(
                flow.Url,
                risk.title(sprintf("CSRF Vulnerability: %s", flow.Url)),
                risk.titleVerbose(sprintf("CSRF跨站请求伪造漏洞: %s", flow.Url)),
                risk.details({"url": flow.Url, "method": "POST"}),
                risk.type("csrf"),
                risk.severity("high"),
                risk.request(res.RequestRaw),
                risk.response(res.ResponseRaw),
                risk.description("应用程序缺少CSRF保护机制，攻击者可以伪造用户请求。"),
                risk.solution("1. 实现CSRF Token机制。\n2. 验证Referer和Origin头。\n3. 使用SameSite Cookie属性。")
            )
        }
    }
} else {
    aiOut("请求包含CSRF Token,可能有CSRF保护")
}

aiOut("=== CSRF检测完成 ===")
