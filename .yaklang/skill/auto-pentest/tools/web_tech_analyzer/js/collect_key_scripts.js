(() => {
  const normalizeUrl = (u) => {
    try { return new URL(u, window.location.href).href; } catch (e) { return u; }
  };
  const isSameOrigin = (u) => {
    try { return new URL(u, window.location.href).origin === window.location.origin; } catch (e) { return false; }
  };

  const perfScripts = (() => {
    try {
      return performance.getEntriesByType('resource')
        .filter(e => e.initiatorType === 'script')
        .map(e => normalizeUrl(e.name));
    } catch (e) {
      return [];
    }
  })();

  const scriptEls = Array.from(document.scripts).map((s, i) => ({
    id: `script_${i}`,
    src: s.src ? normalizeUrl(s.src) : null,
    type: s.type || null,
    async: !!s.async,
    defer: !!s.defer,
    nomodule: !!s.noModule,
    inline: !s.src,
    text: !s.src ? s.textContent || '' : ''
  }));

  const scriptMap = new Map();
  scriptEls.forEach(s => {
    if (s.src) {
      scriptMap.set(s.src, s);
    } else {
      scriptMap.set(s.id, s);
    }
  });
  perfScripts.forEach(src => {
    if (!scriptMap.has(src)) {
      scriptMap.set(src, { id: `perf_${scriptMap.size}`, src, type: null, async: false, defer: false, nomodule: false, inline: false, text: '' });
    }
  });

  const patterns = [
    { key: 'network', re: /(fetch\s*\()|(axios\.)|(XMLHttpRequest)|(jQuery\.ajax|\.ajax\()|(new\s+WebSocket)/g, weight: 4 },
    { key: 'api', re: /(https?:\/\/[^\s"'`]+\/api\/[^\s"'`]*)|(\/api\/[^\s"'`]+)/g, weight: 4 },
    { key: 'graphql', re: /\bgraphql\b|\bApolloClient\b/g, weight: 4 },
    { key: 'auth', re: /\b(auth|login|logout|token|jwt|oauth|sso|bearer)\b/ig, weight: 2 },
    { key: 'config', re: /\b(baseURL|apiBase|endpoint|service|gateway|appId|clientId)\b/ig, weight: 2 },
    { key: 'route', re: /\b(router|routes|route|createRouter|RouterModule|react-router)\b/ig, weight: 1 },
    { key: 'pwa', re: /\bserviceWorker\b|\bnavigator\.serviceWorker\b/g, weight: 1 },
    { key: 'ws', re: /\bwebsocket\b|\bsocket\.io\b|\bio\(/ig, weight: 2 }
  ];

  const analyzeText = (text) => {
    const signals = [];
    const apiSamples = [];
    let score = 0;
    patterns.forEach(p => {
      const matches = text.match(p.re);
      if (matches && matches.length) {
        signals.push(p.key);
        score += p.weight;
        if (p.key === 'api') {
          apiSamples.push(...matches.slice(0, 5));
        }
      }
    });
    return { score, signals: Array.from(new Set(signals)), apiSamples: Array.from(new Set(apiSamples)).slice(0, 8) };
  };

  const scoreByName = (src) => {
    if (!src) return 0;
    const name = src.toLowerCase();
    let s = 0;
    if (name.includes('main') || name.includes('app')) s += 1;
    if (name.includes('chunk') || name.includes('bundle')) s += 1;
    if (name.includes('vendor') || name.includes('lib')) s -= 1;
    return s;
  };

  const candidates = Array.from(scriptMap.values()).map(s => {
    const content = s.inline ? s.text : '';
    const analysis = analyzeText(content);
    const score = analysis.score + scoreByName(s.src);
    return {
      id: s.id,
      src: s.src,
      inline: s.inline,
      type: s.type,
      async: s.async,
      defer: s.defer,
      nomodule: s.nomodule,
      size: s.inline ? content.length : null,
      score,
      signals: analysis.signals,
      apiSamples: analysis.apiSamples,
      fetched: false,
      fetchError: null,
      status: 'unknown'
    };
  });

  const needsFetch = candidates
    .filter(c => !c.inline && c.src && isSameOrigin(c.src) && (c.signals.length === 0))
    .slice(0, 20);

  const fetchScript = (c) => {
    return fetch(c.src, { credentials: 'include' })
      .then(r => r.text())
      .then(text => {
        const analysis = analyzeText(text);
        const score = analysis.score + scoreByName(c.src);
        c.fetched = true;
        c.size = text.length;
        c.score = Math.max(c.score, score);
        c.signals = Array.from(new Set(c.signals.concat(analysis.signals)));
        c.apiSamples = Array.from(new Set(c.apiSamples.concat(analysis.apiSamples))).slice(0, 8);
      })
      .catch(e => {
        c.fetched = false;
        c.fetchError = e ? String(e.message || e) : 'fetch_failed';
      });
  };

  const finalizeStatus = (c) => {
    if (c.score >= 6 || c.signals.includes('network') || c.signals.includes('api') || c.signals.includes('graphql')) return 'need';
    if (c.score >= 2 || c.signals.length) return 'unknown';
    return 'skip';
  };

  const run = async () => {
    await Promise.all(needsFetch.map(fetchScript));
    candidates.forEach(c => { c.status = finalizeStatus(c); });
    candidates.sort((a, b) => b.score - a.score);
    const summary = {
      total: candidates.length,
      need: candidates.filter(c => c.status === 'need').length,
      unknown: candidates.filter(c => c.status === 'unknown').length,
      skip: candidates.filter(c => c.status === 'skip').length
    };
    const result = {
      summary,
      candidates: candidates.slice(0, 50),
      need: candidates.filter(c => c.status === 'need').map(c => c.src || c.id),
      unknown: candidates.filter(c => c.status === 'unknown').map(c => c.src || c.id),
      skip: candidates.filter(c => c.status === 'skip').map(c => c.src || c.id)
    };
    try { window.__KEY_SCRIPTS__ = result; } catch (e) {}
    return JSON.stringify(result);
  };

  return run();
})();
