(() => {
  if (window.__NET_HOOK__) {
    return JSON.stringify({ installed: true, reused: true });
  }
  window.__NET_HOOK__ = { requests: [] };

  const MAX_BODY_LEN = 2000;
  const safeSlice = (s) => {
    if (typeof s !== 'string') return s;
    return s.length > MAX_BODY_LEN ? s.slice(0, MAX_BODY_LEN) : s;
  };
  const headersToObject = (headers) => {
    const out = {};
    try {
      if (!headers) return out;
      if (headers instanceof Headers) {
        headers.forEach((v, k) => { out[k] = v; });
        return out;
      }
      if (Array.isArray(headers)) {
        headers.forEach(pair => {
          if (pair && pair.length >= 2) out[pair[0]] = String(pair[1]);
        });
        return out;
      }
      if (typeof headers === 'object') {
        Object.keys(headers).forEach(k => { out[k] = String(headers[k]); });
      }
    } catch (e) {}
    return out;
  };
  const normalizeParams = (params) => {
    const out = {};
    try {
      params.forEach((v, k) => {
        if (out[k] === undefined) out[k] = v;
        else if (Array.isArray(out[k])) out[k].push(v);
        else out[k] = [out[k], v];
      });
    } catch (e) {}
    return out;
  };
  const parseUrlParams = (url) => {
    try {
      const u = new URL(url, window.location.href);
      return normalizeParams(u.searchParams);
    } catch (e) {
      return null;
    }
  };
  const serializeFormData = (fd) => {
    const out = {};
    try {
      for (const [k, v] of fd.entries()) {
        let val = v;
        if (v instanceof File || v instanceof Blob) {
          val = { name: v.name || null, type: v.type || null, size: v.size || null };
        }
        if (out[k] === undefined) out[k] = val;
        else if (Array.isArray(out[k])) out[k].push(val);
        else out[k] = [out[k], val];
      }
    } catch (e) {}
    return out;
  };
  const parseUrlEncoded = (s) => {
    try {
      return normalizeParams(new URLSearchParams(s));
    } catch (e) {
      return null;
    }
  };
  const parseBody = (body, headers) => {
    if (body == null) return { raw: null, parsed: null };
    if (typeof FormData !== 'undefined' && body instanceof FormData) {
      return { raw: '[formdata]', parsed: serializeFormData(body) };
    }
    if (typeof URLSearchParams !== 'undefined' && body instanceof URLSearchParams) {
      const raw = safeSlice(body.toString());
      return { raw, parsed: parseUrlEncoded(raw) };
    }
    if (typeof body === 'string') {
      const raw = safeSlice(body);
      const ct = headers && (headers['content-type'] || headers['Content-Type'] || '');
      if (ct.includes('application/json')) {
        try { return { raw, parsed: JSON.parse(body) }; } catch (e) {}
      }
      if (ct.includes('application/x-www-form-urlencoded')) {
        return { raw, parsed: parseUrlEncoded(body) };
      }
      const t = body.trim();
      if ((t.startsWith('{') && t.endsWith('}')) || (t.startsWith('[') && t.endsWith(']'))) {
        try { return { raw, parsed: JSON.parse(body) }; } catch (e) {}
      }
      return { raw, parsed: null };
    }
    if (typeof body === 'object') {
      return { raw: '[object]', parsed: body };
    }
    return { raw: safeSlice(String(body)), parsed: null };
  };
  const readFetchBody = async (input, init, headers) => {
    if (init && init.body != null) return parseBody(init.body, headers);
    try {
      if (typeof Request !== 'undefined' && input instanceof Request) {
        const clone = input.clone();
        const text = await clone.text();
        if (text != null && text !== '') return parseBody(text, headers);
      }
    } catch (e) {}
    return { raw: null, parsed: null };
  };
  const captureStack = () => {
    try {
      const stack = (new Error()).stack || '';
      const lines = stack.split('\n').slice(1, 10).map(l => l.trim()).filter(Boolean);
      const urls = [];
      lines.forEach(l => {
        const m = l.match(/(https?:\/\/[^\s)]+)|((?:\/|\.)[^\s)]+\.(?:js|mjs))/i);
        if (m) urls.push(m[0]);
      });
      return { lines, sources: Array.from(new Set(urls)).slice(0, 5) };
    } catch (e) {
      return { lines: [], sources: [] };
    }
  };

  // fetch
  if (window.fetch) {
    const origFetch = window.fetch;
    window.fetch = async function(input, init) {
      try {
        const url = (typeof input === 'string') ? input : input.url;
        const method = (init && init.method) || (input && input.method) || 'GET';
        const headers = headersToObject((init && init.headers) || (input && input.headers));
        const bodyInfo = await readFetchBody(input, init, headers);
        const trace = captureStack();
        window.__NET_HOOK__.requests.push({
          type: 'fetch',
          url,
          method,
          headers,
          query: parseUrlParams(url),
          body: bodyInfo.raw,
          bodyParsed: bodyInfo.parsed,
          stack: trace.lines,
          stackSources: trace.sources
        });
      } catch (e) {}
      return origFetch.apply(this, arguments);
    };
  }

  // XHR
  const OrigXHR = window.XMLHttpRequest;
  if (OrigXHR) {
    function XHRProxy() {
      const xhr = new OrigXHR();
      let method = 'GET';
      let url = '';
      let reqHeaders = {};
      const origOpen = xhr.open;
      xhr.open = function(m, u) { method = m; url = u; return origOpen.apply(this, arguments); };
      const origSetHeader = xhr.setRequestHeader;
      xhr.setRequestHeader = function(k, v) {
        try { reqHeaders[k] = String(v); } catch (e) {}
        return origSetHeader.apply(this, arguments);
      };
      const origSend = xhr.send;
      xhr.send = function(body) {
        try {
          const bodyInfo = parseBody(body, reqHeaders);
          const trace = captureStack();
          window.__NET_HOOK__.requests.push({
            type: 'xhr',
            url,
            method,
            headers: reqHeaders,
            query: parseUrlParams(url),
            body: bodyInfo.raw,
            bodyParsed: bodyInfo.parsed,
            stack: trace.lines,
            stackSources: trace.sources
          });
        } catch (e) {}
        return origSend.apply(this, arguments);
      };
      return xhr;
    }
    window.XMLHttpRequest = XHRProxy;
  }

  // axios
  if (window.axios && window.axios.interceptors && window.axios.interceptors.request) {
    window.axios.interceptors.request.use(function(config) {
      try {
        const headers = headersToObject(config.headers);
        const bodyInfo = parseBody(config.data, headers);
        const trace = captureStack();
        window.__NET_HOOK__.requests.push({
          type: 'axios',
          url: config.url,
          method: (config.method || 'GET').toUpperCase(),
          headers,
          params: config.params || parseUrlParams(config.url) || null,
          data: config.data || null,
          body: bodyInfo.raw,
          bodyParsed: bodyInfo.parsed,
          stack: trace.lines,
          stackSources: trace.sources
        });
      } catch (e) {}
      return config;
    });
  }

  return JSON.stringify({ installed: true, reused: false });
})();
