__DESC__ = "ä¸€ä¸ªYakæ’ä»¶è°ƒç”¨å™¨ï¼Œæ”¯æŒ MITMã€port-scanã€nuclei ä¸‰ç§æ’ä»¶ç±»å‹ã€‚è‡ªåŠ¨æŒ‰ç±»å‹åˆ†ç»„æ‰§è¡Œï¼Œå¯ä»¥æŒ‡å®šå¤šä¸ªæ’ä»¶åï¼Œä½¿ç”¨é€—å·åˆ†éš”ã€‚"
__VERBOSE_NAME__ = "Yakæ’ä»¶è°ƒç”¨å™¨(å¤šç±»å‹æ”¯æŒ)"
__KEYWORDS__ = "æ’ä»¶è°ƒç”¨,MITMæ’ä»¶,port-scan,nuclei,æ’ä»¶æ‰§è¡Œ,HTTPè¯·æ±‚,æ’ä»¶ç®¡ç†,åé¦ˆæœºåˆ¶,plugin caller,mitm plugin,plugin execution,http request,plugin management,feedback mechanism,yak plugin,hook manager"

pluginNames = cli.String("names", cli.setHelp("æ’ä»¶ååˆ—è¡¨ï¼ˆåŒä¸€ç«¯å£å»ºè®®ä¸€æ¬¡æ€§æ‰¹é‡ä¼ å…¥ï¼Œé€—å·åˆ†éš”ï¼›ç¦æ­¢åŒç«¯å£é€æ’ä»¶å¾ªç¯å¤šæ¬¡è°ƒç”¨ï¼‰"), cli.setRequired(true))
targetUrl = cli.Text("url", cli.setHelp("è¯·æ±‚URLï¼ˆå¦‚ http://192.168.1.1:8080ï¼‰"), cli.setRequired(true))
reqPacket = cli.Text("requestPacket", cli.setHelp("è¯·æ±‚æŠ¥æ–‡ï¼ˆä»…MITMç±»å‹éœ€è¦ï¼Œå¯é€‰ï¼‰"))
isHttpsStr = cli.String("isHttps", cli.setHelp("æ˜¯å¦æ˜¯https"))

cli.check()

// ç”Ÿæˆå”¯ä¸€çš„ RuntimeId ç”¨äºè¿½è¸ªé£é™©
runtimeId = str.RandStr(32)

// è§£æ URL å‚æ•°
isHttps = isHttpsStr == "true"
if targetUrl != "" {
    if str.HasPrefix(str.ToLower(targetUrl), "https://") {
        isHttps = true
    }
}

// å¦‚æœæ²¡æœ‰ä¼ å…¥è¯·æ±‚åŒ…ï¼Œåˆ™æ ¹æ® URL ç”Ÿæˆä¸€ä¸ªåŸºç¡€è¯·æ±‚åŒ…
if reqPacket == "" && targetUrl != "" {
    isHttps, req, err = poc.ParseUrlToHTTPRequestRaw("GET", targetUrl)
    if err {
        yakit.Error("è§£æURLï¼Œç”Ÿæˆè¯·æ±‚åŒ…å‡ºé”™: %v" % err)
        return
    }
    reqPacket = req
}

pluginNameList = str.Split(pluginNames, ",")

// æŒ‰ç±»å‹åˆ†ç»„æ’ä»¶
pluginsByType = {
    "nuclei": [],
    "port-scan": [],
    "mitm": []
}

yakit.Info("å¼€å§‹åŠ è½½æ’ä»¶å¹¶æŒ‰ç±»å‹åˆ†ç»„...")
for plugin in pluginNameList {
    plugin = str.Trim(plugin, " ")
    if plugin == "" {
        continue
    }
    
    // è·å–æ’ä»¶ç±»å‹
    scriptInfo, err = db.GetYakitPluginByName(plugin)
    if err != nil || scriptInfo == nil {
        yakit.Error("è·å–æ’ä»¶ä¿¡æ¯å¤±è´¥ [%s]: %v", plugin, err)
        continue
    }
    
    pluginType = scriptInfo.Type
    if pluginType == "" {
        pluginType = "mitm"  // é»˜è®¤ä½¿ç”¨ MITM ç±»å‹
    }
    
    // åªæ”¯æŒè¿™ä¸‰ç§ç±»å‹
    if pluginType != "nuclei" && pluginType != "port-scan" && pluginType != "mitm" {
        pluginType = "mitm"
    }
    
    plugins = pluginsByType[pluginType]
    plugins = append(plugins, plugin)
    pluginsByType[pluginType] = plugins
}

// æ˜¾ç¤ºåˆ†ç»„ä¿¡æ¯
for pType, plugins in pluginsByType {
    if len(plugins) > 0 {
        yakit.Info("æ’ä»¶ç±»å‹ [%s]: %d ä¸ªæ’ä»¶", pType, len(plugins))
    }
}

yakit.Info("ç›®æ ‡URL: %s", targetUrl)
yakit.Info("RuntimeId: %s", runtimeId)

// æ‰§è¡Œå•ä¸ªç±»å‹çš„æ’ä»¶
executePluginsByType = (pluginType, pluginList) => {
    if len(pluginList) == 0 {
        return
    }
    
    yakit.Info("=== æ‰§è¡Œ %s ç±»å‹æ’ä»¶ (%dä¸ª) ===", pluginType, len(pluginList))
    
    // ä¸ºæ¯ç§ç±»å‹åˆ›å»ºç‹¬ç«‹çš„ caller
    manager, err = hook.NewMixPluginCaller()
    if err != nil {
        yakit.Error("åˆ›å»º caller å¤±è´¥: %v", err)
        return
    }
    manager.SetRuntimeId(runtimeId)
    
    // è®¾ç½®åé¦ˆ
    manager.SetFeedback(func(i){
        try {
            msg = json.loads(i.Message)
            data = msg.content.data
            level = msg.content.level 
            
            // è¿‡æ»¤æ‰åˆå§‹åŒ–ä¿¡æ¯å’Œç©ºä¿¡æ¯
            dataStr = sprintf("%v", data)
            if dataStr == "" || dataStr == "{}" || dataStr == "null" {
                return
            }
            if str.Contains(dataStr, "Initializing") || str.Contains(dataStr, "åˆå§‹åŒ–") || str.Contains(dataStr, "load plugin") {
                return
            }
            
            switch level {
            case "info":
                yakit.Info("[%s] %s", pluginType, data)
            case "error":
                yakit.Error("[%s] %s", pluginType, data)
            default:
                yakit.Info("[%s][%s] %s", pluginType, level, data)
            }
        } catch err {
            // å¿½ç•¥è§£æé”™è¯¯
        }
    })
    
    // åŠ è½½æ’ä»¶
    for plugin in pluginList {
        err = manager.LoadPlugin(plugin)
        if err != nil {
            yakit.Error("åŠ è½½æ’ä»¶å¤±è´¥ [%s]: %v", plugin, err)
        }
    }
    
    // æ ¹æ®ç±»å‹é€‰æ‹©æ‰§è¡Œæ–¹å¼
    switch pluginType {
    case "nuclei":
        yakit.Info("æ‰§è¡Œ Nuclei æ‰«æ...")
        manager.MirrorHTTPFlowExSync(true, isHttps, targetUrl, reqPacket, "", "")
        
    case "port-scan":
        yakit.Info("æ‰§è¡Œç«¯å£æ‰«ææ’ä»¶...")
        manager.MirrorHTTPFlowExSync(true, isHttps, targetUrl, "", "", "")
        
    default:
        yakit.Info("æ‰§è¡Œ MITM æ’ä»¶...")
        if reqPacket == "" {
            yakit.Error("MITMæ’ä»¶éœ€è¦è¯·æ±‚åŒ…")
            return
        }
        rsp, req, err = poc.HTTP(reqPacket, poc.https(isHttps), poc.redirectTimes(0))
        if err {
            yakit.Error("è¯·æ±‚ç›®æ ‡å¤±è´¥: %v", err)
            return
        }
        body = poc.GetHTTPPacketBody(reqPacket)
        manager.MirrorHTTPFlowExSync(true, isHttps, targetUrl, req, rsp, body)
    }
    
    manager.Wait()
    yakit.Info("=== %s ç±»å‹æ’ä»¶æ‰§è¡Œå®Œæˆ ===", pluginType)
}

// å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰ç±»å‹çš„æ’ä»¶
wg = sync.NewWaitGroup()

for pType, plugins in pluginsByType {
    if len(plugins) > 0 {
        wg.Add(1)
        pType := pType
        plugins := plugins
        go func() {
            defer wg.Done()
            executePluginsByType(pType, plugins)
        }()
    }
}

wg.Wait()
yakit.Info("æ‰€æœ‰æ’ä»¶æ‰§è¡Œå®Œæˆ")

// æŸ¥è¯¢é€šè¿‡ risk.NewRisk() äº§ç”Ÿçš„æ¼æ´è®°å½•
yakit.Info("=== æŸ¥è¯¢æ¼æ´è®°å½• (RuntimeId: %s) ===", runtimeId)
riskCount = 0
for riskItem in risk.YieldRiskByRuntimeId(runtimeId) {
    riskCount++
    yakit.Info("ğŸ”´ å‘ç°æ¼æ´ [%s]: %s", riskItem.Severity, riskItem.Title)
    yakit.Info("   ç›®æ ‡: %s", riskItem.IP)
    if riskItem.TitleVerbose != "" {
        yakit.Info("   è¯¦æƒ…: %s", riskItem.TitleVerbose)
    }
}

if riskCount > 0 {
    yakit.Info("=== å…±å‘ç° %d ä¸ªæ¼æ´ ===", riskCount)
} else {
    yakit.Info("=== æœªå‘ç°æ¼æ´ ===")
}
