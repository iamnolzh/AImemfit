__DESC__ = "基于上下文感知和 AST 分析的高级 XSS 检测工具，支持反射型 XSS，通过精准的 HTML/JS 解析降低误报。"
__VERBOSE_NAME__ = "高级 XSS 智能检测 (Context-Aware)"
__KEYWORDS__ = "xss,context-aware,ast-analysis,reflected-xss,advanced-detection,yakit"

// 配置项
debug = false  // 开发调试模式
threads = 10   // 并发线程数

// CLI 参数定义
flowIDStr = cli.String(
    "httpflow-id", 
    cli.setVerboseName("HTTPFlowID"), 
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"), 
    cli.setRequired(true), 
)
cli.check()

// 辅助输出函数
aiOut = msg => { 
    try {
        yakit.AIOutput(msg) 
    } catch {
        println(msg)
    }
}

// 日志配置与输出封装
origin_yakit_output = yakit_output
yakit_output_wrapper = func(v) {
    if debug {
        println(v)
    } else {
        if origin_yakit_output != nil {
            origin_yakit_output(v)
        } else {
            try {
                yakit.Output(v)
            } catch {
                println(v)
            }
        }
    }
}

// -------------------------------------------------------------------
// 核心数据结构与辅助函数
// -------------------------------------------------------------------

/*
newPayload 构造函数
*/
newPayload = func(value, dangerousChars, payloadType) {
    return {"value": value, "dangerousChars": dangerousChars, "payloadType": payloadType }
}

/*
newResult 构造结果对象
*/
newResult = func(maybeVuln, url, param, payload, reqRaw, respRaw) {
    return {"maybeVuln": maybeVuln, "url": url, "param": param, "payload": payload, "reqRaw": reqRaw, "respRaw": respRaw }
}

// 检查错误并退出
checkErr = func(err) {
    if err != nil {
        errMsg := sprintf("XSS-DETECT Error: %s", err.Error())
        if debug {
            println(errMsg)
        }
    }
}

// 漏洞描述与方案
description  = `XSS (Cross-Site Scripting) 是一种常见的 Web 安全漏洞，允许攻击者将恶意脚本注入到网页中，在其他用户的浏览器上执行。
本插件使用高级上下文感知技术 (Context-Aware) 和 AST (抽象语法树) 分析，能够精确检测反射型 XSS，极大降低误报率。`

solution = `1. 输入过滤：对用户输入进行严格的白名单验证。
2. 输出编码：在输出到 HTML 上下文时进行实体编码 (HTML Entity Encoding)。
3. 使用 HTTP-only Cookie：防止 JS 窃取 Session。
4. CSP (Content Security Policy)：配置内容安全策略限制脚本执行。`

// -------------------------------------------------------------------
// 核心逻辑: 日志与风险上报
// -------------------------------------------------------------------

// 报告漏洞
reportVuln = func(result) {
    maybeVuln = result.maybeVuln
    url = result.url
    param = result.param 
    payload = result.payload
    reqRaw = result.reqRaw  
    respRaw = result.respRaw
    
    msg = "Found Confirmed XSS"
    severity = "high"
    if maybeVuln {
        msg = "Found Suspected XSS (High Confidence)"
        severity = "medium"
    }

    payloadString := sprintf("%s=%s", param.Name(), payload.value)
    
    // 构造结构化报告
    report = {
        "message": msg,
        "payload": payloadString,
        "payload_type": payload.payloadType,
        "param_name": param.Name(),
        "param_position": param.PositionVerbose(),
        "context": "Context-Aware Detection",
    }
    
    // 输出到 Yakit UI
    aiOut(sprintf("✓ %s: %s (Type: %s)", msg, payloadString, payload.payloadType))

    // 录入风险数据库
    risk.NewRisk(
        url,
        risk.title(sprintf("XSS (%s): %s", payload.payloadType, url)),
        risk.titleVerbose(sprintf("XSS 跨站脚本漏洞检测: %s", url)),
        risk.details(report),
        risk.description(description),
        risk.solution(solution),
        risk.type("xss"),
        risk.payload(payloadString),
        risk.request(reqRaw), 
        risk.response(respRaw),
        risk.severity(severity),
    )
}

// -------------------------------------------------------------------
// 核心逻辑: 特殊属性判断
// -------------------------------------------------------------------

// 判断 HTML 属性是否为事件处理器 (Event Handler)
isEventAttr = func(attrName) {
    attrName = str.ToUpper(attrName)
    // 常见事件处理器列表
    // 简单判断前缀
    if str.HasPrefix(attrName, "ON") {
        return true
    }
    return false
}

// 针对特殊属性构造 Payload
specialAttrPayload = func(attrName, verifyRandStr) {
    if attrName == "STYLE" {
        return sprintf("xss:expression(prompt('%s'))", verifyRandStr)
    }
    return sprintf("prompt('%s')", verifyRandStr)
}

// -------------------------------------------------------------------
// 核心逻辑: Fuzz 与 检测
// -------------------------------------------------------------------

// Rawfuzz: 发送 Payload 并获取原始请求/响应
Rawfuzz = func(param, fuzzPayload) {
    freq = param.Fuzz(fuzzPayload)
    
    httpReq, err = freq.GetFirstFuzzHTTPRequest()
    if err != nil { return nil, nil, nil }
    
    rawReq, err = httpReq.GetOriginHTTPRequest()
    if err != nil { return nil, nil, nil }
    
    reqBody, err = http.dump(rawReq)
    if err != nil { return nil, nil, nil }

    respChannel, err = freq.Exec()
    if err != nil { return nil, nil, nil }
    
    rsp = <-respChannel
    if rsp == nil { return nil, nil, nil }
    
    respBody, err = str.ExtractBodyFromHTTPResponseRaw(rsp.ResponseRaw)
    if err != nil { return rsp.Response, reqBody, []byte{} }

    return rsp.Response, reqBody, respBody
}

// payloadFuzzTask: 针对单个 Payload 执行检测与验证
payloadFuzzTask = func(swg, resultCh, url, param, verifyRandStr, payload) {
    swg.Add()
    go func {
        defer swg.Done()
        
        rsp, reqBody, newBody = Rawfuzz(param, payload.value)
        if rsp == nil { return }

        existVuln = false
        maybeVuln = false
        payloadType = payload.payloadType

        if payloadType == "js" {
            // JS 上下文：使用 AST 分析
            verifyMatchNodes = xhtml.Find(newBody, verifyRandStr)
            for _, matchNode = range verifyMatchNodes {
                if matchNode.TagName != "script" { continue }
                
                result, err = js.ASTWalk(matchNode.MatchText)
                
                if err != nil {
                    existVuln = true
                    maybeVuln = true 
                    break
                }

                for _, s = range result.StringLiteral {
                    if s == verifyRandStr {
                        existVuln = true
                        break
                    }
                }
                
                if len(result.BadSyntax) > 0 {
                    existVuln = true
                    maybeVuln = true
                    break
                }
            }
        
        } else if payloadType == "comment" {
            // 注释上下文
            verifyMatchNodes = xhtml.Find(newBody, verifyRandStr)
            for _, matchNode = range verifyMatchNodes {
                if matchNode.IsText() && matchNode.MatchText == verifyRandStr {
                    existVuln = true
                    break
                }
            }
            
        } else if str.HasPrefix(payloadType, "spec") {
            // 特殊属性
            existVuln = true
            maybeVuln = true
            
        } else {
            // Tag 或 Attr 上下文
            verifyMatchNodes = xhtml.Find(newBody, verifyRandStr)
            for _, matchNode = range verifyMatchNodes {
                if matchNode.IsAttr() {
                    if matchNode.Key == "id" && matchNode.Val == verifyRandStr {
                        existVuln = true
                        break
                    }
                }
            }
        }

        if existVuln {
            contentType = ""
            try { contentType = rsp.Header["Content-Type"][0] } catch {}
            
            if contentType == "" || str.Contains(str.ToLower(contentType), "html") {
                result = newResult(maybeVuln, url, param, payload, reqBody, newBody)
                resultCh <- result
            }
        }
    }
}

// paramFuzzTask: 针对单个参数的完整检测流程
paramFuzzTask = func(threads, url, param) {
    aiOut(sprintf("正在检测参数: %s", param.Name()))

    // 1. 探测阶段
    randStr = str.RandStr(5)
    verifyRandStr = str.RandStr(8)

    _, reqBody, rawBody = Rawfuzz(param, randStr)
    if rawBody == nil { return }

    // 2. 定位回显
    matchNodes = xhtml.Find(rawBody, randStr)
    if len(matchNodes) == 0 {
        return 
    }

    // 3. 构造 Payload
    payloads = []
    
    for _, matchNode = range matchNodes {
        if matchNode.IsText() {
            if matchNode.TagName == "script" {
                matchText = matchNode.MatchText
                randIdx = str.Index(matchText, randStr)
                quote = ""
                
                if randIdx > 0 {
                    payloads = append(payloads, newPayload(sprintf("';prompt('%s');//", verifyRandStr), "'", "js"))
                    payloads = append(payloads, newPayload(sprintf("\";prompt('%s');//", verifyRandStr), "\"", "js"))
                    payloads = append(payloads, newPayload(sprintf("1;prompt('%s');//", verifyRandStr), ";", "js"))
                }
                
                payloads = append(payloads, newPayload(sprintf("</script><img src=x id='%s' onerror=alert(1)>", verifyRandStr), "</>", "tag"))
                
            } else {
                closeTag = sprintf("</%s>", matchNode.TagName)
                payloadStr = sprintf("%s<img src=x id='%s' onerror=alert(1)>", closeTag, verifyRandStr)
                payloads = append(payloads, newPayload(payloadStr, "<>/", "tag"))
                
                payloads = append(payloads, newPayload(sprintf("<img src=x id='%s' onerror=alert(1)>", verifyRandStr), "<>", "tag"))
            }
        } else if matchNode.IsAttr() {
            attrName = str.ToUpper(matchNode.Key)
            
            if isEventAttr(attrName) || attrName == "STYLE" {
                p = specialAttrPayload(attrName, verifyRandStr)
                payloads = append(payloads, newPayload(p, "", "spec-attr"))
            } else {
                prefix = "\">"
                suffix = sprintf("<img src=x id='%s' onerror=alert(1)>", verifyRandStr)
                payloads = append(payloads, newPayload(prefix + suffix, "\">", "attr"))
                
                prefix = "'>"
                payloads = append(payloads, newPayload(prefix + suffix, "'>", "attr"))
                
                prefix = ">"
                payloads = append(payloads, newPayload(prefix + suffix, ">", "attr"))
            }
        } else if matchNode.IsCOMMENT() {
            payloads = append(payloads, newPayload(sprintf("-->%s<img src=x id='%s' onerror=alert(1)><!--", verifyRandStr, verifyRandStr), "-->", "comment"))
        }
    }

    if len(payloads) == 0 { return }
    
    // 4. 执行 Fuzz
    swg = sync.NewSizedWaitGroup(threads)
    resultCh = make(chan map[string]var, len(payloads) + 5)
    
    for _, p = range payloads {
        payloadFuzzTask(swg, resultCh, url, param, verifyRandStr, p)
    }
    swg.Wait()
    close(resultCh)
    
    // 5. 收集结果
    reported = false
    for res = range resultCh {
        if !reported {
            reportVuln(res)
            reported = true 
        }
    }
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始高级智能 XSS 检测 (Target: %s)...", flow.Url))

allParams = freq.GetCommonParams()
validParams = []
ignoredParams = ["PHPSESSID", "JSESSIONID", "_ga", "_gid", "submit", "Submit"]
for param in allParams {
    ignore = false
    for _, i = range ignoredParams {
        if str.MatchAllOfRegexp(param.Name(), sprintf("(?i)%s", i)) {
            ignore = true
            break
        }
    }
    if !ignore {
        validParams = append(validParams, param)
    }
}

if len(validParams) == 0 {
    aiOut("未发现可测试的有效参数")
    return
}

for param in validParams {
    paramFuzzTask(threads, flow.Url, param)
}

aiOut("=== 高级智能 XSS 检测完成 ===")