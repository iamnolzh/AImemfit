__KEYWORDS__ = "brute force,service,socks4 proxy,snmpv3,tomcat,mssql,ftp,rdp,http proxy,postgres"
__VERBOSE_NAME__ = "服务弱口令爆破"
__DESC__ = <<<EOF
brute service[socks4_proxy,snmpv3_sha-256,tomcat,mssql,snmpv3_md5,snmpv3_sha-384,ftp,rdp,snmpv2,http_proxy,socks4a_proxy,postgres,smb,imap,smtp,vnc,redis,mongodb,telnet,socks5_proxy,ssh,oracle,memcached,pop3,snmpv3_sha,snmpv3_sha-224,snmpv3_sha-512,rtsp,pptp,mysql,ldap]
支持批量目标输入，格式：IP:端口:服务类型，一次性对所有服务进行弱口令爆破
EOF

yakit.AutoInitYakit()
targets = cli.String("targets", cli.setRequired(true), cli.setHelp("目标列表，格式：IP:端口:服务类型，多个用逗号分隔"))
concurrent = cli.Int("concurrent", cli.setDefault(50), cli.setHelp("并发数"))
concurrentTarget = cli.Int("concurrent-target", cli.setDefault(10), cli.setHelp("目标并发数"))
minDelay = cli.Int("min-delay", cli.setDefault(0), cli.setHelp("最小延迟（毫秒）"))
maxDelay = cli.Int("max-delay", cli.setDefault(0), cli.setHelp("最大延迟（毫秒）"))

cli.check()

// 按服务类型分组的用户名/密码字典，减少无效请求
serviceCreds = {
    "ssh": {
        "users": ['root','ubuntu','centos','admin','oracle','debian','test','git','admin1'],
        "passes": ['','root','123456','abc*123','password','admin','toor','123456789','admin123','ubuntu','centos','12345','12345678','qwerty','P@ssw0rd','a123456'],
    },
    "mysql": {
        "users": ['root','mysql','admin','test','user'],
        "passes": ['','root','123456','mysql','password','admin','123456789','admin123','root123','12345','toor','P@ssw0rd','mysql123'],
    },
    "postgres": {
        "users": ['postgres','admin','root','test'],
        "passes": ['','postgres','123456','password','admin','123456789','admin123','12345','postgresql'],
    },
    "redis": {
        "users": [''],  // Redis 无用户名，用空占位
        "passes": ['','redis','123456','password','admin','default','123456789','foobared'],
    },
    "mongodb": {
        "users": ['admin','root','mongodb','user','test'],
        "passes": ['','123456','admin','password','mongodb','admin123','123456789','root','12345'],
    },
    "ftp": {
        "users": ['ftp','anonymous','admin','root','user','test'],
        "passes": ['','ftp','123456','admin','password','anonymous','admin123','123456789','ftp123','12345'],
    },
    "rdp": {
        "users": ['administrator','admin','Administrator','guest','test'],
        "passes": ['','123456','password','admin','admin123','123456789','12345','P@ssw0rd','12345678','administrator'],
    },
    "mssql": {
        "users": ['sa','admin','administrator','test'],
        "passes": ['','123456','password','admin','sa','Admin123','123456789','12345','P@ssw0rd','Sql123456'],
    },
    "oracle": {
        "users": ['system','sys','scott','admin','dbsnmp'],
        "passes": ['','oracle','123456','password','admin','manager','123456789','oracle123','tiger','12345'],
    },
    "telnet": {
        "users": ['root','admin','user','guest','test'],
        "passes": ['','root','123456','admin','password','12345','123456789','admin123','toor'],
    },
    "smb": {
        "users": ['administrator','admin','guest','test','user'],
        "passes": ['','123456','password','admin','123456789','admin123','12345','P@ssw0rd',''],
    },
    "vnc": {
        "users": [''],  // VNC 通常只有密码
        "passes": ['','123456','password','vnc','admin','12345','123456789','admin123','vnc123'],
    },
    "tomcat": {
        "users": ['tomcat','admin','manager','root'],
        "passes": ['','tomcat','123456','admin','manager','admin123','123456789','s3cret','password'],
    },
    "memcached": {
        "users": [''],
        "passes": ['','123456','memcached','password','admin'],
    },
}

// 获取服务对应的用户名和密码列表，未定义的服务使用通用字典
getCredsForService = func(serviceType) {
    serviceLower = str.ToLower(serviceType)
    if serviceLower in serviceCreds {
        creds = serviceCreds[serviceLower]
        users = creds["users"]
        passes = creds["passes"]
        // 过滤空字符串占位（如 Redis 单密码模式）
        if len(users) == 1 && users[0] == "" {
            users = ['']  // 保留空，brute 会处理
        }
        return users, passes
    }
    // 通用兜底
    users = ['root','admin','administrator','test','guest','user']
    passes = ['','123456','password','admin','123456789','admin123','12345','root','P@ssw0rd']
    return users, passes
}

// 解析目标列表，格式：IP:端口:服务类型
targetList = []
items = str.Split(targets, ",")
for item in items {
    item = str.TrimSpace(item)
    if item == "" {
        continue
    }
    // 解析 IP:端口:服务类型
    if str.Contains(item, ":") {
        parts = str.Split(item, ":")
        if len(parts) >= 3 {
            ip = str.TrimSpace(parts[0])
            portStr = str.TrimSpace(parts[1])
            serviceType = str.TrimSpace(parts[2])
            // 直接使用字符串拼接，不需要转换为整数
            if ip != "" && portStr != "" && serviceType != "" {
                target = ip + ":" + portStr
                targetList.Push({
                    "target": target,
                    "ip": ip,
                    "port": portStr,
                    "serviceType": serviceType
                })
            } else {
                yakit.Warn("目标格式错误，跳过: %s (格式应为 IP:端口:服务类型)", item)
            }
        } else {
            yakit.Warn("目标格式错误，跳过: %s (格式应为 IP:端口:服务类型)", item)
        }
    }
}

if len(targetList) == 0 {
    yakit.Error("没有有效的目标，请检查输入格式（IP:端口，多个用逗号分隔）")
    return
}

yakit.Info("共解析到 %d 个目标，开始前置验证", len(targetList))

// 服务验证函数：验证端口是否真的是对应的服务
verifyService = func(target, serviceType) {
    // 解析 IP 和端口
    parts = str.Split(target, ":")
    if len(parts) != 2 {
        return false
    }
    ip = parts[0]
    portStr = parts[1]
    
    // 使用 servicescan 快速验证服务类型
    opts = []
    opts.Push(servicescan.probeTimeout(3))  // 3秒超时，快速验证
    opts.Push(servicescan.concurrent(1))     // 单个验证，不需要高并发
    
    // 根据服务类型设置扫描选项
    if serviceType == "ssh" {
        opts.Push(servicescan.service())
    } else if serviceType == "mysql" || serviceType == "postgres" || serviceType == "mssql" || serviceType == "oracle" {
        opts.Push(servicescan.service())
    } else if serviceType == "redis" || serviceType == "mongodb" || serviceType == "memcached" {
        opts.Push(servicescan.service())
    } else if serviceType == "ftp" || serviceType == "telnet" || serviceType == "rdp" {
        opts.Push(servicescan.service())
    } else {
        opts.Push(servicescan.service())
    }
    
    // 执行扫描验证
    results, err := servicescan.Scan(ip, portStr, opts...)
    if err != nil {
        return false
    }
    
    // 检查结果
    for result in results {
        if !result.IsOpen() {
            return false
        }
        glance = result.String()
        banner = result.GetBanner()
        
        // 根据服务类型检查响应特征
        glanceLower = str.ToLower(glance)
        bannerLower = str.ToLower(banner)
        combined = glanceLower + " " + bannerLower
        
        // 检查是否明显不匹配（如果包含其他服务的明显特征，则拒绝）
        if serviceType == "ssh" {
            // SSH 特征：包含 SSH 协议标识
            if str.Contains(combined, "ssh") || str.Contains(combined, "ssh-") {
                return true
            }
            // 如果明显是其他服务，拒绝
            if str.Contains(combined, "mysql") || str.Contains(combined, "http") || str.Contains(combined, "ftp") {
                return false
            }
            // 端口 22 且没有明显不匹配，认为可能是 SSH（允许通过）
            if portStr == "22" {
                return true
            }
        } else if serviceType == "mysql" {
            // MySQL 特征：包含 MySQL 相关标识，或者端口是 3306 且没有明显不匹配
            if str.Contains(combined, "mysql") {
                return true
            }
            // 如果明显是其他服务，拒绝
            if str.Contains(combined, "ssh") || str.Contains(combined, "http") || str.Contains(combined, "ftp") {
                return false
            }
            // 端口 3306 且没有明显不匹配，认为可能是 MySQL（允许通过）
            if portStr == "3306" {
                return true
            }
        } else if serviceType == "redis" {
            // Redis 特征：通常返回 +OK 或 Redis 版本信息
            if str.Contains(combined, "redis") || str.Contains(combined, "+ok") {
                return true
            }
            // 端口 6379 且没有明显不匹配，认为可能是 Redis
            if portStr == "6379" {
                return true
            }
        } else if serviceType == "postgres" {
            // PostgreSQL 特征
            if str.Contains(combined, "postgresql") || str.Contains(combined, "postgres") {
                return true
            }
            // 端口 5432 且没有明显不匹配，认为可能是 PostgreSQL
            if portStr == "5432" {
                return true
            }
        } else if serviceType == "ftp" {
            // FTP 特征：通常返回 220 欢迎消息
            if str.Contains(combined, "ftp") || str.Contains(combined, "220") {
                return true
            }
            // 端口 21 且没有明显不匹配，认为可能是 FTP
            if portStr == "21" {
                return true
            }
        } else if serviceType == "rdp" {
            // RDP 特征
            if str.Contains(combined, "rdp") || str.Contains(combined, "microsoft terminal services") {
                return true
            }
            // 端口 3389 且没有明显不匹配，认为可能是 RDP
            if portStr == "3389" {
                return true
            }
        } else if serviceType == "mongodb" {
            // MongoDB 特征
            if str.Contains(combined, "mongodb") {
                return true
            }
            // 端口 27017 且没有明显不匹配，认为可能是 MongoDB
            if portStr == "27017" {
                return true
            }
        } else if serviceType == "telnet" {
            // Telnet 特征
            if str.Contains(combined, "telnet") {
                return true
            }
            // 端口 23 且没有明显不匹配，认为可能是 Telnet
            if portStr == "23" {
                return true
            }
        } else {
            // 其他服务：如果端口开放且没有明显不匹配，认为验证通过
            return true
        }
    }
    
    return false
}

// 前置验证：过滤掉不是对应服务的目标
verifiedTargetList = []
skippedCount = 0

yakit.Info("开始前置验证，验证端口是否为对应服务...")
for targetInfo in targetList {
    target = targetInfo["target"]
    serviceType = targetInfo["serviceType"]
    
    if verifyService(target, serviceType) {
        verifiedTargetList.Push(targetInfo)
    } else {
        skippedCount++
        yakit.Warn("验证失败，跳过: %s (不是 %s 服务)", target, serviceType)
    }
}

if len(verifiedTargetList) == 0 {
    yakit.Error("所有目标验证失败，没有可爆破的目标")
    return
}

yakit.Info("前置验证完成：通过 %d 个，跳过 %d 个", len(verifiedTargetList), skippedCount)

// 按服务类型分组
serviceTargetMap = {}
for targetInfo in verifiedTargetList {
    serviceType = targetInfo["serviceType"]
    if serviceType not in serviceTargetMap {
        serviceTargetMap[serviceType] = []
    }
    // 先获取数组，添加元素，再赋值回去
    targetArray = serviceTargetMap[serviceType]
    targetArray.Push(targetInfo["target"])
    serviceTargetMap[serviceType] = targetArray
}

yakit.Info("当前配置：并发数=%d, 目标并发数=%d, 延迟范围=%d-%d毫秒", concurrent, concurrentTarget, minDelay, maxDelay)

// 对每种服务类型进行爆破
totalFound = 0
totalAttempts = 0
startTime = time.Now()

for serviceType, targetListForService in serviceTargetMap {
    // 针对数据库服务（MySQL、PostgreSQL等）建议使用更高的并发数
    currentConcurrent = concurrent
    if serviceType == "mysql" || serviceType == "postgres" || serviceType == "mssql" || serviceType == "oracle" {
        // 数据库服务连接失败较多，提高并发可以加快速度
        if currentConcurrent < 100 {
            currentConcurrent = 100
            yakit.Info("检测到数据库服务 %s，自动提高并发数到 %d 以加快速度", serviceType, currentConcurrent)
        }
    }
    
    yakit.Info("=== 开始爆破服务类型: %s (共 %d 个目标) ===", serviceType, len(targetListForService))
    
    // 按服务类型获取专属用户名/密码字典，减少无效请求
    users, passes = getCredsForService(serviceType)
    yakit.Info("使用 %s 专属字典: %d 用户 x %d 密码", serviceType, len(users), len(passes))
    
    opts = []
    opts.Push(brute.userList(users...))
    opts.Push(brute.passList(passes...))
    
    // 并发控制：提高并发数可以显著加快爆破速度
    opts.Push(brute.concurrent(currentConcurrent))
    
    // 目标并发数：用于批量目标扫描
    opts.Push(brute.concurrentTarget(concurrentTarget))
    
    // 延迟控制：如果触发防护，可以设置延迟范围（毫秒）
    if minDelay > 0 || maxDelay > 0 {
        if minDelay > 0 {
            opts.Push(brute.minDelay(minDelay))
        }
        if maxDelay > 0 {
            opts.Push(brute.maxDelay(maxDelay))
        }
        // 如果只设置了其中一个，使用相同的值
        if minDelay > 0 && maxDelay == 0 {
            opts.Push(brute.maxDelay(minDelay))
        }
        if maxDelay > 0 && minDelay == 0 {
            opts.Push(brute.minDelay(maxDelay))
        }
    }
    
    // 找到第一个正确凭证后立即停止（默认行为，显式设置确保生效）
    opts.Push(brute.okToStop(true))
    
    // 创建爆破实例
    ins, err = brute.New(serviceType, opts...)
    if err != nil {
        yakit.Error("创建 %s 服务爆破实例失败: %v", serviceType, err)
        continue
    }
    
    // 对所有该类型的目标进行爆破（支持批量目标）
    targetStr = str.Join(targetListForService, ",")
    result, err := ins.Start(targetStr)
    if err != nil {
        yakit.Error("%s 服务爆破失败: %v", serviceType, err.Error())
        continue
    }
    
    // 处理结果
    count = 0
    foundSuccess = false
    for i in result {
        totalAttempts = totalAttempts + 1
        
        if i.Ok {
            count++
            totalFound++
            elapsed = time.Since(startTime).Seconds()
            yakit.Info("result: %v (尝试次数: %d, 耗时: %.2f秒)", i.String(), totalAttempts, elapsed)
            foundSuccess = true
            // 找到第一个正确的凭证后立即停止，不再测试剩下的账号密码
            // 注意：okToStop(true) 已设置，但 break 确保立即退出循环
            break
        }
        // 静默处理失败，减少输出
    }
    
    if count > 0 {
        yakit.Info("服务类型 %s 爆破完成，找到 %d 个有效凭证", serviceType, count)
    }
}

elapsed = time.Since(startTime).Seconds()
yakit.Info("=== 批量弱口令爆破完成 ===")
yakit.Info("总目标数: %d, 找到有效凭证: %d 个, 总尝试次数: %d, 总耗时: %.2f秒", len(targetList), totalFound, totalAttempts, elapsed)
