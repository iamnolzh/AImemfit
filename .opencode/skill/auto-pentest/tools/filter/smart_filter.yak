// 智能流量筛选与脚本匹配 - 一步完成流量筛选和漏洞脚本分发
// 使用: yak smart_filter.yak --target-host "192.168.3.24"

yakit.AutoInitYakit()

targetHost = cli.String("target-host", cli.setRequired(true), cli.setHelp("目标主机（如 192.168.3.24 或 example.com）"))
maxFlows = cli.Int("max-flows", cli.setDefault(100), cli.setHelp("最多处理的 Flow 数量"))
cli.check()

yakit.Info(sprintf("开始智能筛选与脚本匹配: %s", targetHost))

// 脚本匹配规则
scriptRules = {
    "xss.yak": {
        "priority": 1,
        "conditions": ["GET", "POST"],
        "keywords": ["message", "name", "search", "comment", "content", "q", "text"],
        "always_run": true,  // 对所有有参数的请求都运行
    },
    "ssrf.yak": {
        "priority": 1,
        "conditions": ["GET", "POST"],
        "keywords": ["url", "link", "redirect", "uri", "callback", "proxy", "fetch", "webhook"],
        "path_keywords": ["redirect", "proxy", "fetch"],
    },
    "file_upload.yak": {
        "priority": 2,
        "conditions": ["POST"],
        "keywords": ["file", "upload", "image", "avatar", "photo", "attachment"],
        "path_keywords": ["upload", "attachment"],
        "content_type": ["multipart/form-data"],
    },
    "xxe.yak": {
        "priority": 2,
        "conditions": ["POST"],
        "content_type": ["application/xml", "text/xml"],
        "path_keywords": ["xml", "soap"],
    },
    "command_injection.yak": {
        "priority": 1,
        "conditions": ["GET", "POST"],
        "keywords": ["cmd", "command", "exec", "system", "ping", "shell", "run"],
        "path_keywords": ["exec", "ping", "cmd"],
    },
    "file_read.yak": {
        "priority": 2,
        "conditions": ["GET", "POST"],
        "keywords": ["file", "path", "dir", "read", "download", "doc", "page"],
        "path_keywords": ["download", "read", "file"],
    },
    "open_redirect.yak": {
        "priority": 1,
        "conditions": ["GET"],
        "keywords": ["url", "redirect", "return", "next", "goto", "target"],
        "path_keywords": ["redirect", "goto"],
    },
    "ssti.yak": {
        "priority": 3,
        "conditions": ["GET", "POST"],
        "keywords": ["template", "tpl", "render", "view"],
        "path_keywords": ["template", "render"],
    },
    "xpath_injection.yak": {
        "priority": 3,
        "conditions": ["GET", "POST"],
        "keywords": ["user", "username", "search", "query", "filter"],
        "path_keywords": ["xpath", "search"],
    },
    "sensitive_info_leak.yak": {
        "priority": 2,
        "always_run": false,
        "keywords": ["admin", "config", "debug", "info", "status"],
    },
}

// 静态资源扩展名列表（更全面）
staticExtensions = [
    // 脚本和样式
    ".js", ".css", ".map",
    // 图片
    ".png", ".jpg", ".jpeg", ".gif", ".svg", ".ico", ".webp", ".bmp", ".tiff",
    // 字体
    ".woff", ".woff2", ".ttf", ".eot", ".otf",
    // 文档和媒体
    ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
    ".mp3", ".mp4", ".avi", ".mov", ".wmv", ".flv",
    // 其他静态资源
    ".zip", ".rar", ".tar", ".gz", ".7z",
]

// 分析单个 Flow 并决定运行哪些脚本
analyzeFlow = func(flow) {
    url = flow.Url
    method = flow.Method
    contentType = ""
    try { contentType = flow.Request.ContentType() } catch {}
    
    // 提取参数名
    paramNames = []
    freq, err = fuzz.HTTPRequest(flow.GetRequest(), fuzz.https(flow.IsHTTPS))
    if err == nil {
        params = freq.GetCommonParams()
        for param in params {
            paramNames = append(paramNames, str.ToLower(param.Name()))
        }
    }
    
    // URL 路径转小写
    urlLower = str.ToLower(url)
    contentTypeLower = str.ToLower(contentType)
    
    // 判断每个脚本是否应该运行
    selectedScripts = []
    
    for scriptName, rule = range scriptRules {
        shouldRun = false
        matchReason = ""
        
        // 1. 检查是否总是运行
        if rule["always_run"] && len(paramNames) > 0 {
            shouldRun = true
            matchReason = "高优先级脚本"
        }
        
        // 2. 检查方法匹配
        methodMatch = false
        conditions = rule["conditions"]
        if conditions != undefined {
            for _, m = range conditions {
                if method == m {
                    methodMatch = true
                    break
                }
            }
        } else {
            methodMatch = true
        }
        
        if !methodMatch { continue }
        
        // 3. 检查参数名关键词
        keywords = rule["keywords"]
        if keywords != undefined {
            for _, keyword = range keywords {
                for _, paramName = range paramNames {
                    if str.Contains(paramName, keyword) {
                        shouldRun = true
                        matchReason = sprintf("参数名匹配: %s", paramName)
                        break
                    }
                }
                if shouldRun { break }
            }
        }
        
        // 4. 检查路径关键词
        pathKeywords = rule["path_keywords"]
        if pathKeywords != undefined && !shouldRun {
            for _, keyword = range pathKeywords {
                if str.Contains(urlLower, keyword) {
                    shouldRun = true
                    matchReason = sprintf("路径匹配: %s", keyword)
                    break
                }
            }
        }
        
        // 5. 检查 Content-Type
        ctList = rule["content_type"]
        if ctList != undefined && !shouldRun {
            for _, ct = range ctList {
                if str.Contains(contentTypeLower, ct) {
                    shouldRun = true
                    matchReason = sprintf("Content-Type 匹配: %s", ct)
                    break
                }
            }
        }
        
        if shouldRun {
            selectedScripts = append(selectedScripts, {
                "name": scriptName,
                "priority": rule["priority"],
                "reason": matchReason,
            })
        }
    }
    
    return selectedScripts
}

// 主逻辑
flows = db.QueryHTTPFlowsByKeyword(targetHost)

executionPlan = []
totalScripts = 0
processedCount = 0

for f = range flows {
    // 达到最大处理数量则停止
    if processedCount >= maxFlows {
        yakit.Warn(sprintf("已达到最大处理数量 %d，停止筛选", maxFlows))
        break
    }
    
    url = f.Url
    method = f.Method
    
    // 第一步：粗筛选 - 排除静态资源
    // 检查 URL 路径（去除查询参数后）是否为静态资源
    urlPath = url
    if url.Contains("?") {
        urlPath = str.Split(url, "?")[0]
    }

    isStatic = false
    for _, ext = range staticExtensions {
        if urlPath.HasSuffix(ext) {
            isStatic = true
            break
        }
    }

    // 如果是静态资源，直接跳过（即使带参数也是静态资源）
    if isStatic {
        continue
    }

    // 检查是否有参数或为 POST 请求
    hasParams = url.Contains("?") || method == "POST"

    // 如果没有参数，也跳过
    if !hasParams {
        continue
    }
    
    // 第二步：智能匹配脚本
    scripts = analyzeFlow(f)
    
    if len(scripts) == 0 {
        continue
    }
    
    // 输出匹配结果
    yakit.Info(sprintf("✓ [Flow %d] %s %s", f.Model.ID, method, url))
    for _, script = range scripts {
        yakit.Info(sprintf("  → %s (优先级:%d, 原因:%s)", script["name"], script["priority"], script["reason"]))
    }
    
    executionPlan = append(executionPlan, {
        "flow_id": f.Model.ID,
        "url": url,
        "method": method,
        "scripts": scripts,
    })
    
    totalScripts = totalScripts + len(scripts)
    processedCount++
}

// 输出统计
yakit.Info("\n" + "="*60)
yakit.Info("智能筛选与脚本匹配完成：")
yakit.Info(sprintf("  - 处理了 %d 个有效目标", len(executionPlan)))
yakit.Info(sprintf("  - 总计需要运行 %d 次脚本", totalScripts))
yakit.Info(sprintf("  - 平均每个目标运行 %.1f 个脚本", float64(totalScripts) / float64(len(executionPlan))))
yakit.Info("="*60)

// 输出执行计划（JSON格式）
println("\n<<<EXECUTION_PLAN_START>>>")
println(json.dumps(executionPlan))
println("<<<EXECUTION_PLAN_END>>>")
