(() => {
  const normalizeUrl = (u) => {
    try { return new URL(u, window.location.href).href; } catch (e) { return u; }
  };
  const isSameOrigin = (u) => {
    try { return new URL(u, window.location.href).origin === window.location.origin; } catch (e) { return false; }
  };

  const scriptEls = Array.from(document.scripts).map((s, i) => ({
    id: `script_${i}`,
    src: s.src ? normalizeUrl(s.src) : null,
    inline: !s.src,
    type: s.type || null,
    text: !s.src ? (s.textContent || '') : ''
  }));

  const perfScripts = (() => {
    try {
      return performance.getEntriesByType('resource')
        .filter(e => e.initiatorType === 'script')
        .map(e => normalizeUrl(e.name));
    } catch (e) {
      return [];
    }
  })();

  const scriptMap = new Map();
  scriptEls.forEach(s => {
    if (s.src) scriptMap.set(s.src, s);
    else scriptMap.set(s.id, s);
  });
  perfScripts.forEach(src => {
    if (!scriptMap.has(src)) {
      scriptMap.set(src, { id: `perf_${scriptMap.size}`, src, inline: false, type: null, text: '' });
    }
  });

  const keyScripts = (() => {
    try { return window.__KEY_SCRIPTS__ || null; } catch (e) { return null; }
  })();

  const stackSources = (() => {
    try {
      const reqs = (window.__NET_HOOK__ && window.__NET_HOOK__.requests) || [];
      const sources = [];
      reqs.forEach(r => {
        if (Array.isArray(r.stackSources)) sources.push(...r.stackSources);
        if (Array.isArray(r.stack)) {
          r.stack.forEach(line => {
            const m = line.match(/(https?:\/\/[^\s)]+)|((?:\/|\.)[^\s)]+\.(?:js|mjs))/i);
            if (m) sources.push(m[0]);
          });
        }
      });
      return Array.from(new Set(sources.map(normalizeUrl)));
    } catch (e) {
      return [];
    }
  })();

  const signalsFromKey = new Map();
  if (keyScripts && Array.isArray(keyScripts.candidates)) {
    keyScripts.candidates.forEach(c => {
      const key = c.src || c.id;
      signalsFromKey.set(key, c);
    });
  }

  const heuristicSignals = (text) => {
    if (!text) return { score: 0, signals: [] };
    const signals = [];
    let score = 0;
    const add = (cond, key, weight) => {
      if (!cond) return;
      if (!signals.includes(key)) signals.push(key);
      score += weight;
    };
    add(/(fetch\s*\()|(axios\.)|(XMLHttpRequest)|(jQuery\.ajax|\.ajax\()|(new\s+WebSocket)/.test(text), 'network', 4);
    add(/(https?:\/\/[^\s"'`]+\/api\/[^\s"'`]*)|(\/api\/[^\s"'`]+)/.test(text), 'api', 4);
    add(/\bgraphql\b|\bApolloClient\b/.test(text), 'graphql', 4);
    add(/\b(auth|login|logout|token|jwt|oauth|sso|bearer)\b/i.test(text), 'auth', 2);
    add(/\b(baseURL|apiBase|endpoint|service|gateway|appId|clientId)\b/i.test(text), 'config', 2);
    return { score, signals };
  };

  const candidates = Array.from(scriptMap.values()).map(s => {
    const key = s.src || s.id;
    const fromKey = signalsFromKey.get(key);
    const heur = s.inline ? heuristicSignals(s.text) : { score: 0, signals: [] };
    const isDynamicHit = s.src ? stackSources.includes(s.src) : false;
    const reasons = [];
    if (isDynamicHit) reasons.push('dynamic_stack');
    if (fromKey && fromKey.signals && fromKey.signals.length) reasons.push('static_signals');
    if (heur.signals.length) reasons.push('inline_signals');
    if (fromKey && fromKey.apiSamples && fromKey.apiSamples.length) reasons.push('api_samples');
    return {
      id: s.id,
      src: s.src,
      inline: s.inline,
      type: s.type,
      sameOrigin: s.src ? isSameOrigin(s.src) : true,
      dynamicHit: isDynamicHit,
      signals: Array.from(new Set([...(fromKey ? fromKey.signals || [] : []), ...heur.signals])),
      score: (fromKey ? fromKey.score || 0 : 0) + heur.score + (isDynamicHit ? 5 : 0),
      reasons
    };
  });

  const classify = (c) => {
    if (c.dynamicHit) return 'need';
    if (c.signals.includes('network') || c.signals.includes('api') || c.signals.includes('graphql')) return 'need';
    if (c.score >= 3 || c.signals.length) return 'unknown';
    return 'skip';
  };

  candidates.forEach(c => { c.status = classify(c); });
  candidates.sort((a, b) => b.score - a.score);

  const need = candidates.filter(c => c.status === 'need').map(c => c.src || c.id);
  const unknown = candidates.filter(c => c.status === 'unknown').map(c => c.src || c.id);
  const skip = candidates.filter(c => c.status === 'skip').map(c => c.src || c.id);

  const summary = {
    total: candidates.length,
    need: need.length,
    unknown: unknown.length,
    skip: skip.length,
    dynamicSources: stackSources.length
  };

  return JSON.stringify({
    summary,
    need,
    unknown,
    skip,
    candidates: candidates.slice(0, 80)
  });
})();
