#!/bin/bash

# 网页分析工具 - AI友好版
# 使用: ./web_analyzer.sh <URL>

TARGET="${1:-http://27.148.194.107:9091}"
SESSION="web_$(date +%s)"
TMP_DIR="/tmp/$SESSION"
mkdir -p "$TMP_DIR"

# 获取脚本所在目录，以便通过相对路径引用其他文件
BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
YAK_SCRIPT="$BASE_DIR/web_analyzer.yak"
JS_DIR="$BASE_DIR/../js"

# 进度输出到 stderr，不污染 stdout
echo "[1/4] 打开页面: $TARGET" >&2
yak "$YAK_SCRIPT" --open "$TARGET" --session "$SESSION" --js-dir "$JS_DIR" > /dev/null 2>&1
sleep 5

# 2. 技术栈分析
echo "[2/4] 分析技术栈..." >&2
OUTPUT=$(yak "$YAK_SCRIPT" --eval detect_stack.js --session "$SESSION" --js-dir "$JS_DIR" 2>&1)
echo "$OUTPUT" | python3 <(cat << 'PYEOF'
import sys, json, re, os
try:
    input_data = sys.stdin.read()
    match = re.search(r'<<<JSON_START>>>\s*(.*?)\s*<<<JSON_END>>>', input_data, re.DOTALL)
    if match:
        val = match.group(1).strip()
        data = json.loads(val)
        if isinstance(data, str): data = json.loads(data)
        with open(sys.argv[1] + "/stack.json", "w") as f:
            json.dump(data, f)
except: pass
PYEOF
) "$TMP_DIR"

# 3. 路由提取
echo "[3/4] 提取路由..." >&2
OUTPUT=$(yak "$YAK_SCRIPT" --eval vue_routes.js --session "$SESSION" --js-dir "$JS_DIR" 2>&1)
echo "$OUTPUT" | python3 <(cat << 'PYEOF'
import sys, json, re, os
try:
    input_data = sys.stdin.read()
    match = re.search(r'<<<JSON_START>>>\s*(.*?)\s*<<<JSON_END>>>', input_data, re.DOTALL)
    if match:
        val = match.group(1).strip()
        data = json.loads(val)
        if isinstance(data, str): data = json.loads(data)
        with open(sys.argv[1] + "/routes.json", "w") as f:
            json.dump(data, f)
except: pass
PYEOF
) "$TMP_DIR"

# 4. 脚本资源
echo "[4/4] 收集脚本资源..." >&2
OUTPUT=$(yak "$YAK_SCRIPT" --eval collect_scripts.js --session "$SESSION" --js-dir "$JS_DIR" 2>&1)
echo "$OUTPUT" | python3 <(cat << 'PYEOF'
import sys, json, re, os
try:
    input_data = sys.stdin.read()
    match = re.search(r'<<<JSON_START>>>\s*(.*?)\s*<<<JSON_END>>>', input_data, re.DOTALL)
    if match:
        val = match.group(1).strip()
        data = json.loads(val)
        if isinstance(data, str): data = json.loads(data)
        with open(sys.argv[1] + "/scripts.json", "w") as f:
            json.dump(data, f)
except: pass
PYEOF
) "$TMP_DIR"

# 5. RequireJS配置
echo "[+  ] 分析模块配置..." >&2
OUTPUT=$(yak "$YAK_SCRIPT" --eval collect_requirejs_config.js --session "$SESSION" --js-dir "$JS_DIR" 2>&1)
echo "$OUTPUT" | python3 <(cat << 'PYEOF'
import sys, json, re, os
try:
    input_data = sys.stdin.read()
    match = re.search(r'<<<JSON_START>>>\s*(.*?)\s*<<<JSON_END>>>', input_data, re.DOTALL)
    if match:
        val = match.group(1).strip()
        data = json.loads(val)
        if isinstance(data, str): data = json.loads(data)
        with open(sys.argv[1] + "/require.json", "w") as f:
            json.dump(data, f)
except: pass
PYEOF
) "$TMP_DIR"

# 关闭浏览器
yak "$YAK_SCRIPT" --close --session "$SESSION" --js-dir "$JS_DIR" > /dev/null 2>&1

# 合并结果并输出精简 JSON
python3 <(cat << 'PYEOF'
import sys, json, os

result = {
    "target": sys.argv[2],
    "time": sys.argv[3], # Shortened key
    "data": {} # Shortened key
}

tmp_dir = sys.argv[1]

def load_json(name):
    try:
        with open(os.path.join(tmp_dir, name), 'r') as f:
            return json.load(f)
    except:
        return {}

# 1. Stack: 只保留识别到的 (True)
full_stack = load_json("stack.json").get("stack") or {}
result["data"]["tech_stack"] = [k for k, v in full_stack.items() if v]

# 2. Routes: 保持原样 (列表)
result["data"]["routes"] = load_json("routes.json").get("routes") or []

# 3. Scripts: 极大简化
# - 外部脚本: 只保留 src
# - 内联脚本: 标记为 "Inline: <前30字符>..."
scripts = load_json("scripts.json").get("scripts") or []
simple_scripts = []
for s in scripts:
    if not s: continue
    if s.get("src"):
        simple_scripts.append(s["src"])
    elif s.get("inline"):
        sample = (s.get("textSample") or "").replace("\n", " ").strip()[:30]
        simple_scripts.append(f"Inline: {sample}...")
result["data"]["scripts"] = simple_scripts

# 4. RequireJS: 只保留 Map 映射
req_config = load_json("require.json").get("requirejsConfig") or {}
result["data"]["module_map"] = req_config.get("map", {}).get("*", {})

print(json.dumps(result, ensure_ascii=False, indent=2))
PYEOF
) "$TMP_DIR" "$TARGET" "$(date)"

# 清理临时文件
rm -rf "$TMP_DIR"
