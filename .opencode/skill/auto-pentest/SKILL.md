---
name: auto-pentest
description: 全自动渗透测试。快速模式（用户明确框架名如 ThinkPHP/Weblogic）：查插件→执行；全流程模式（用户说"全流程测试"）：端口扫描→指纹→POC→爬虫→漏洞脚本→弱口令
---

# Automatic Pentest Workflow - 全自动渗透测试执行器

## 📂 工作目录（必读，否则报 no such file or directory）

**⚠️ 路径必读**：阶段1～4 的所有命令必须在**本 skill 所在目录**下执行。当前工作目录往往不是项目根，因此**不要**使用相对路径 `cd .opencode/skill/auto-pentest`，否则会报 `no such file or directory` 导致阶段1 无法执行。

**正确做法**：用 skill 工具加载本 skill 时，工具会返回一行 **Base directory**: `<绝对路径>`（例如 `/Users/xxx/evil-opencode-main/.opencode/skill/auto-pentest`）。**必须**用该绝对路径作为工作目录：
1. 先执行：`cd "<Base directory>"`（将 `<Base directory>` 替换为工具返回的完整路径）
2. 再执行各阶段的 `./tools/...` 或 `yak tools/...`、`yak script/...`

下文命令中的 **`<SKILL_BASE_DIR>`** 均指该 Base directory，请替换为实际绝对路径后再执行；若未加载 skill 或未拿到路径，先调用 skill 工具加载本 skill 再继续。

阶段0、0b、0c、0d、5 的脚本已并入本技能目录下的 **tools/port_scan/**（scan_tcp_port.yak、query_service_fingerprint.yak、query_plugin_by_fp.yak、call_yak_plugin.yak、brute.yak），与阶段1～4 一样均先 `cd "<SKILL_BASE_DIR>"` 再执行 `yak tools/port_scan/...`。

**备选（仅当当前目录已是项目根时有效）**：若你确认当前工作目录是含 `.opencode` 的项目根，才可使用 `cd .opencode/skill/auto-pentest`。

**环境依赖**：本技能所有阶段均通过 `yak` 执行 `.yak` 脚本（端口扫描、爬虫、漏洞检测等）。在 **Linux / 换一台机器** 使用时，用户需在本机安装 [YakRunner](https://yaklang.com) 并保证 `yak` 在 PATH 中（`yak version` 可输出版本即表示可用），否则会报 `yak: command not found`。

---

## 🚀 快速检测模式（用户明确指定框架时优先）

**触发条件**：用户说「检测 xxx 是否存在 <框架名> 漏洞」，且**明确指定了框架/产品名**（如 ThinkPHP、Weblogic、Tomcat、Struts2、Spring、Shiro 等）。

**执行流程**（两步，不跑全流程）：

### 步骤1：查询相关插件
```bash
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/query_plugin_by_fp.yak --fingerprints "<框架名小写>"
```
- `<框架名小写>`：用户指定的框架（如 `thinkphp`、`weblogic`、`tomcat`）
- 脚本输出匹配到的 POC 插件名列表

### 步骤2：执行插件
```bash
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/call_yak_plugin.yak --names "<插件1,插件2,...>" --url "<目标URL>"
```
- `<插件1,插件2,...>`：步骤1 输出的插件名，逗号分隔（一次性传入所有插件）。步骤1 可能输出多行「插件名: xxx, 插件介绍: xxx」，需从每行提取插件名后逗号拼接传入 `--names`。
- `<目标URL>`：用户给的目标（如 `http://172.16.102.17:8180/`）

### 示例

用户说：「检测 http://172.16.102.17:8180/ 是否存在 thinkphp 相关漏洞」

```bash
# 1. 查询 thinkphp 相关插件
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/query_plugin_by_fp.yak --fingerprints "thinkphp"
# 输出示例：ThinkPHP 5.x RCE, ThinkPHP SQL注入, ThinkPHP 任意文件读取

# 2. 执行插件（一次性传入所有插件名）
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/call_yak_plugin.yak --names "ThinkPHP 5.x RCE,ThinkPHP SQL注入,ThinkPHP 任意文件读取" --url "http://172.16.102.17:8180/"
```

### 何时用快速模式 vs 全流程

| 用户请求 | 使用模式 |
|----------|----------|
| 「检测 xxx 是否存在 ThinkPHP 漏洞」 | ✅ **快速模式**（查插件→执行） |
| 「测试 xxx 有没有 Weblogic 漏洞」 | ✅ **快速模式** |
| 「用 Struts2 插件扫一下 xxx」 | ✅ **快速模式** |
| 「全流程测试 xxx」「自动渗透 xxx」 | ❌ 全流程（阶段0-5） |
| 「测试 xxx 是否存在 XSS」 | ❌ 全流程（需爬虫→script/xss.yak） |

---

## 🎯 触发条件（全流程模式）

当用户输入以下任意关键词时，**立即启动全流程自动化测试**（不要询问，不要等待确认）：
- "全流程测试 <URL>"
- "自动渗透 <URL>"
- "完整扫描 <URL>"
- "pentest <URL>"

**注意**：若用户明确指定了框架名（如「检测 xxx 是否存在 ThinkPHP 漏洞」），应使用上述**快速检测模式**，而非全流程。

## 执行流程（严格顺序执行）

**⚠️ 必须连续跑完全部阶段，不得在阶段0 后停止。** 全流程：端口扫描(tools/port_scan/scan_tcp_port.yak) → Web 指纹(query_service_fingerprint.yak) → 查 POC(query_plugin_by_fp.yak) → 执行 POC(call_yak_plugin.yak) → 架构指纹(web_tech_analyzer) → 爬虫 → 智能筛选 → 漏洞脚本(xss/ssrf 等) → 弱口令(tools/port_scan/brute.yak)。**所有脚本均在本技能目录下**，先 `cd "<SKILL_BASE_DIR>"` 再执行。

**阶段检查清单**（必须全部完成才能结束，否则视为未完成任务）：
- [ ] 阶段0 端口扫描（tools/port_scan/scan_tcp_port.yak）
- [ ] 阶段0b Web 服务指纹（tools/port_scan/query_service_fingerprint.yak，仅 HTTP/HTTPS 端口）
- [ ] 阶段0c 根据指纹查 POC 插件（tools/port_scan/query_plugin_by_fp.yak）
- [ ] 阶段0d 执行 POC 漏洞检测（tools/port_scan/call_yak_plugin.yak）
- [ ] 阶段1 架构指纹识别（web_tech_analyzer，技术栈）
- [ ] 阶段2 爬虫数据采集
- [ ] 阶段3 智能筛选与脚本匹配
- [ ] 阶段4 漏洞脚本精准打击（xss/ssrf 等）
- [ ] 阶段5 弱口令爆破（tools/port_scan/brute.yak）

**目标解析**：
- 用户给的 `<TARGET_URL>` 可能是**带路径的完整地址**（如 `http://192.168.3.24:8081/vul/xss/xss_reflected_get.php`）或仅根地址（如 `http://192.168.3.24:8081`）。
- 从中解析：**`<TARGET_HOST>`** = 主机（如 `192.168.3.24`）；**`<TARGET_BASE_URL>`** = 协议 + 主机 + 端口（如 `http://192.168.3.24:8081`），用于阶段1～4 的指纹、爬虫、筛选、漏洞检测。
- 阶段0 端口扫描只使用 `<TARGET_HOST>`；阶段1～4 使用 `<TARGET_BASE_URL>`（爬虫会从该根地址开始，不会只测用户给的那一条路径）。

**多端口 Web 服务**：
- 阶段0 若发现**多个端口**存在 Web 服务（如 80、8081、9000），则对**每一个**发现的 Web 服务分别执行阶段1～4（指纹 → 爬虫 → 筛选 → 漏洞脚本）。
- 即：为每个 `http(s)://<TARGET_HOST>:<port>` 构造 `<TARGET_BASE_URL>`，依次对该 URL 跑阶段1、2、3、4，再处理下一个端口。不要只对用户给出的那一个 URL 跑后续流程，而忽略端口扫描发现的其他 Web 端口。

### **阶段0：端口与服务发现** 🔍（tools/port_scan/scan_tcp_port.yak）

使用本技能目录下的 **tools/port_scan/scan_tcp_port.yak** 做 TCP 端口扫描与服务指纹，支持 Web 与非 Web 端口。

**命令**（先 cd 到本技能目录，再执行）:
```bash
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/scan_tcp_port.yak --hosts <TARGET_HOST> --ports 21,22,25,80,110,139,143,443,445,3306,3389,5432,6379,8080,8081,8443,9000,7000,27017 --web
```
参数说明：`--hosts` 目标 IP；`--ports` 端口列表（21/FTP、22/SSH、80/443/8080/8081 等）；`--web` 启用 Web 服务指纹。可选 `--active` 主动探测（更准但更慢）。

**执行要求**:
- 将 `<TARGET_HOST>` 替换为从 TARGET_URL 解析出的主机（域名或 IP）；`<SKILL_BASE_DIR>` 为本技能 Base directory。
- 执行命令并**等待结果**
- 从输出中总结：**开放端口列表**、**Web 端口**、**非 Web 服务**（如 SSH/MySQL/RDP/Redis 等）
- **只向用户汇报**："端口扫描完成，开放端口 [列表]，发现 [N] 个 Web 服务、[M] 个非 Web 服务"
- **完成后必须立即执行阶段0b**，不要在此处停止。

---

### **阶段0b：Web 服务指纹（tools/port_scan/query_service_fingerprint.yak）**

**条件**：仅对阶段0 发现的 **HTTP/HTTPS 端口**执行。若无 Web 端口则**跳过阶段0b、0c、0d**，直接执行阶段1（若有 Web 端口）或阶段5（弱口令）。

**命令**（先 cd 到本技能目录）:
```bash
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/query_service_fingerprint.yak --target <TARGET_HOST> --ports <Web端口列表逗号分隔>
```
示例：若阶段0 发现 80、8081 开放且为 Web，则 `--ports 80,8081`。**输出处理**：记录每个端口识别到的指纹（如 ThinkPHP、Tomcat、nginx），格式为 `端口:指纹`。若结果为「未检测到 web 指纹」，则**跳过阶段0c、0d**，直接进入阶段1 或阶段5。

**执行要求**:
- 将所有 Web 端口在一次命令中传入（逗号分隔）
- 从输出中提取 **端口:指纹** 列表，供阶段0c 使用
- **完成后若存在指纹**：立即执行阶段0c；**若无指纹**：跳过 0c、0d，执行阶段1（对每个 Web URL 跑 web_tech_analyzer）或阶段5

---

### **阶段0c：根据指纹查 POC 插件（tools/port_scan/query_plugin_by_fp.yak）**

**条件**：仅对阶段0b 识别出指纹的服务执行。**规则**：所有指纹必须在一次命令中查询，格式 `端口:指纹,端口:指纹`。

**命令**（先 cd 到本技能目录）:
```bash
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/query_plugin_by_fp.yak --fingerprints "<端口1:指纹1,端口2:指纹2,...>"
```
示例：`--fingerprints "80:ThinkPHP,8081:Tomcat"`。**输出处理**：记录每个端口对应的 POC 插件名称列表。

**执行要求**:
- 将阶段0b 得到的 端口:指纹 拼成一行，逗号分隔，传入 `--fingerprints`
- 从输出中提取每个端口的**插件名列表**，供阶段0d 使用
- **完成后必须立即执行阶段0d**

---

### **阶段0d：执行 POC 漏洞检测（tools/port_scan/call_yak_plugin.yak）**

**条件**：仅对有 POC 插件的端口执行。**规则**：每个端口只执行一次命令，将该端口的所有插件名用逗号拼接传入 `--names`。

**命令**（先 cd 到本技能目录，每个有插件的端口执行一次）:
```bash
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/call_yak_plugin.yak --names "<插件1,插件2,...>" --url "http://<TARGET_HOST>:<端口>"
```
示例：`yak tools/port_scan/call_yak_plugin.yak --names "ThinkPHP-RCE,ThinkPHP-SQLi" --url "http://192.168.3.24:80"`。可选 `--type "port-scan"` 或 `--type "nuclei"`（默认 auto）。

**执行要求**:
- 同一 URL 的所有插件**一次性**传入，禁止对同一端口循环多次调用
- 对每个有 POC 的端口执行一次，收集漏洞结果
- **完成后必须立即执行阶段1**（对每个 Web 端口的 TARGET_BASE_URL 跑 web_tech_analyzer、爬虫、筛选、漏洞脚本）

---

**【阶段0～0d 完成后必做】** 在同一轮回复中立刻执行阶段1，不要等待用户输入。
- 若阶段0 发现多个 Web 端口：对**每个** `http(s)://<TARGET_HOST>:<port>` 分别执行阶段1 → 2 → 3 → 4。阶段1 命令示例（对单个 URL，**必须**先 cd 到 auto-pentest 的 Base directory）：
```bash
cd "<SKILL_BASE_DIR>" && ./tools/web_tech_analyzer/bin/web_analyzer.sh <TARGET_BASE_URL>
```
将 `<SKILL_BASE_DIR>` 替换为 skill 工具返回的 **Base directory** 绝对路径；将 `<TARGET_BASE_URL>` 替换为根地址（如 `http://192.168.3.24:8081`），不要带路径。

---

### **阶段1：架构指纹识别** 🏗（Web 技术栈指纹）
**命令**（先 cd 到 skill 目录，每个 Web 根 URL 执行一次）:
```bash
cd "<SKILL_BASE_DIR>" && ./tools/web_tech_analyzer/bin/web_analyzer.sh <TARGET_BASE_URL>
```
其中 `<SKILL_BASE_DIR>` 为 skill 工具返回的 Base directory 绝对路径。

**执行要求**:
- 使用 `<TARGET_BASE_URL>`（协议+主机+端口，如 `http://192.168.3.24:8081`），不要带路径。若阶段0 发现多个 Web 端口，则对每个端口的 TARGET_BASE_URL 各执行一次本阶段。
- 执行命令并**等待结果**
- 从 JSON 输出中提取 `tech_stack` 字段
- **只向用户汇报**："目标 [URL] 使用 [Vue/React/...] 技术栈"
- **不要**输出完整 JSON，不要列出路由和脚本列表

**【阶段1 完成后必做】** 在同一轮回复中立刻执行阶段2（爬虫）。阶段2 命令示例（对同一 TARGET_BASE_URL）：
```bash
cd "<SKILL_BASE_DIR>/tools/crawler" && ./yak_fast crawler_new.yak --targetUrl <TARGET_BASE_URL> --maxUrl 30 --concurrent 20
```
爬虫仅输出 API 列表（httpflow-id 供后续 script/*.yak 使用）；若需给 AI 看更清晰输出，可管道过滤：`2>&1 | grep -v '\[ERRO\]' | grep -v '\[WARN\]'`。

---

### **阶段2：爬虫数据采集** 🕷
**命令**（先 cd 到 crawler 目录，每个 Web 根 URL 执行一次）:
```bash
cd "<SKILL_BASE_DIR>/tools/crawler" && ./yak_fast crawler_new.yak --targetUrl <TARGET_BASE_URL> --maxUrl 30 --concurrent 20
```

| 参数 | 含义 | 默认取值 |
| --- | --- | --- |
| `--targetUrl` | 爬取目标（根 URL） | 必填，如 `http://192.168.3.24:8081` |
| `--maxUrl` | 最多采集 URL 数 | 30 |
| `--concurrent` | 浏览器并发数 | 20 |

**输出说明**：爬虫仅输出 **API 列表**（httpflow-id 供后续 script/*.yak 使用）。crawlerx 内部可能有 `[ERRO]`/`[WARN]`，若需给 AI 看更清晰输出，可管道过滤：`2>&1 | grep -v '\[ERRO\]' | grep -v '\[WARN\]'`。

**备选（yak 原版）**：`cd "<SKILL_BASE_DIR>" && yak tools/crawler/crawler.yak --targetUrl <TARGET_BASE_URL> --maxUrl 50 --fullTimeout 600 --pageTimeout 15`

**执行要求**:
- **必须等待爬虫完成**（通常需要 300-600 秒）
- 从输出中提取最后几行的 Flow ID 范围（例如：ID:6677 ~ ID:6720）
- **向用户汇报**："爬虫完成，共采集 N 个请求"
- **不要**向用户贴出爬虫的完整逐行日志；若有 `[ERRO]`（如超时、页面 load 失败）属常见情况，脚本仍可能正常结束并写入 flow，不必据此判定阶段失败

**【阶段2 完成后必做】** 在同一轮回复中立刻执行阶段3（智能筛选）。阶段3 命令示例：
```bash
cd "<SKILL_BASE_DIR>" && yak tools/filter/smart_filter.yak --target-host "<TARGET_HOST>" --max-flows 100
```

---

### **阶段3：智能筛选与脚本匹配** 🧠
**命令**（先 cd 到 skill 目录；若有多端口则爬虫数据会按 host 区分，本阶段用 TARGET_HOST 筛选该主机下的 flows）:
```bash
cd "<SKILL_BASE_DIR>" && yak tools/filter/smart_filter.yak --target-host "<TARGET_HOST>" --max-flows 100
```
替换 `<TARGET_HOST>` 为目标主机（如 `192.168.3.24`）。多端口时同一主机下的各端口爬虫结果会一并参与筛选。

**核心功能**：
一步完成两项任务：
1. **粗筛选**：排除静态资源（`.js`, `.css`, `.png`等），只保留有参数的请求
2. **智能匹配**：根据请求特征（方法、参数名、Content-Type、URL路径）精准匹配适用的漏洞检测脚本

**匹配规则示例**：
- 参数名包含 `message` → 匹配 `xss.yak`
- 参数名包含 `url`/`redirect` → 匹配 `ssrf.yak` + `open_redirect.yak`；含 redirect/location 还可匹配 `crlf.yak`
- POST + 参数名包含 `file` → 匹配 `file_upload.yak`
- POST + Content-Type 为 `application/xml` → 匹配 `xxe.yak`
- 参数名包含 `cmd`/`exec` → 匹配 `command_injection.yak`
- 参数名包含 `id`/`name`/`search`/`query`/`keyword`/`user`/`sort`/`order` 等 → 匹配 `sql_injection.yak`
- POST/PUT/DELETE 写操作 → 匹配 `csrf.yak`（检测是否缺 CSRF Token）
- 路径以 `/` 结尾或像目录 → 匹配 `dirlist.yak`
- 任意请求可抽样跑 `headers.yak`、`cors.yak`、`sensitivefile.yak`、`sensitive_info_leak.yak`

**优化效果**：
- 原本：100个目标 × 10种脚本 = **1000次测试**
- 优化后：每个目标平均匹配 **2-3种脚本** = **约250次测试**
- **减少 75% 的无效请求**

**执行要求**:
- 替换 `<TARGET_HOST>` 为目标域名或 IP（如 `192.168.3.24`）
- 从输出中提取 `<<<EXECUTION_PLAN_START>>>` 和 `<<<EXECUTION_PLAN_END>>>` 之间的执行计划 JSON
- **向用户汇报**："筛选出 N 个有效目标，平均每个目标运行 X 个脚本"

**【阶段3 完成后必做】** 在同一轮回复中立刻执行阶段4：根据执行计划中的 Flow ID，对每个 ID 依次运行至少 xss.yak、ssrf.yak、open_redirect.yak，再按请求特征运行其他脚本（见阶段4 智能分发逻辑）。

---

### **阶段4：漏洞脚本精准打击** 🛡

**⚠️ 前置依赖**：本阶段的所有脚本都需要 `--httpflow-id` 参数。该 ID 来自**阶段2 爬虫**产生的请求记录，并由**阶段3 smart_filter.yak** 输出的执行计划提供。**禁止**跳过阶段2、3 直接执行本阶段；禁止传入不存在的 Flow ID（会报「HTTPFlow 查询失败」）。

**策略**：对每个筛选出的 Flow ID，根据请求特征运行适用的检测脚本

**可用检测脚本列表**:
```
script/xss.yak              - XSS 跨站脚本
script/ssrf.yak             - SSRF 服务端请求伪造
script/file_upload.yak      - 文件上传漏洞
script/xxe.yak              - XXE XML外部实体注入
script/command_injection.yak - 命令注入
script/sql_injection.yak     - SQL 注入（报错/布尔/时间盲注）
script/file_read.yak        - 任意文件读取
script/open_redirect.yak    - 开放重定向
script/ssti.yak             - 服务端模板注入
script/xpath_injection.yak  - XPath 注入
script/sensitive_info_leak.yak - 敏感信息泄露
script/cors.yak             - CORS 跨域配置错误
script/crlf.yak             - CRLF 注入 / HTTP 响应拆分
script/csrf.yak             - CSRF 跨站请求伪造（写操作缺 Token）
script/dirlist.yak          - 目录列表泄露
script/headers.yak          - HTTP 安全头缺失与 Server 信息泄露
script/sensitivefile.yak    - 敏感文件/目录暴露（.git、.env、web.config 等）
script/login_check.yak      - 登录/认证检查（GET 首页、GET 登录页、POST 登录、检查 302/Location/Set-Cookie，不依赖 flow）
```

**让 Yak 参与手动测试**：若你用手动 curl 测了首页、登录 POST、响应头等，希望用 Yak 复现或纳入流程：
- **方式一**：直接跑登录检查脚本（不依赖爬虫/flow）：`cd "<SKILL_BASE_DIR>" && yak script/login_check.yak --target http://192.168.3.24:8080`，可选 `--login-path /login.php --username admin --password password`。脚本会 GET 首页、GET 登录页（可自动取 user_token）、POST 登录并输出状态码与 Location/Set-Cookie。
- **方式二**：说「全流程测试 \<URL\>」，由爬虫抓取包含登录页在内的请求，再对每个 flow 跑上述漏洞脚本；登录行为会作为其中一部分被检测。

**智能分发逻辑**（每条命令均先 cd 到 skill 目录，即 `<SKILL_BASE_DIR>`）:
```bash
# 对每个有效的 Flow ID，运行以下脚本（先 cd "<SKILL_BASE_DIR>"）：

# 1. 优先级脚本（对所有有参数的请求都执行）
cd "<SKILL_BASE_DIR>" && yak script/xss.yak --httpflow-id <FLOW_ID>
cd "<SKILL_BASE_DIR>" && yak script/ssrf.yak --httpflow-id <FLOW_ID>
cd "<SKILL_BASE_DIR>" && yak script/open_redirect.yak --httpflow-id <FLOW_ID>

# 2. 根据请求特征选择：
# - 如果是 POST 请求或包含 file/upload 关键词
cd "<SKILL_BASE_DIR>" && yak script/file_upload.yak --httpflow-id <FLOW_ID>

# - 如果 Content-Type 包含 xml 或路径包含 xml
cd "<SKILL_BASE_DIR>" && yak script/xxe.yak --httpflow-id <FLOW_ID>

# - 如果参数名包含 cmd/exec/system/ping 等关键词
cd "<SKILL_BASE_DIR>" && yak script/command_injection.yak --httpflow-id <FLOW_ID>

# - 如果参数名包含 id/name/search/query/keyword/user/sort/order 等（数据库查询场景）
cd "<SKILL_BASE_DIR>" && yak script/sql_injection.yak --httpflow-id <FLOW_ID>

# - 如果参数名包含 file/path/dir/read 等关键词
cd "<SKILL_BASE_DIR>" && yak script/file_read.yak --httpflow-id <FLOW_ID>

# - 如果参数名包含 template/tpl/render 等关键词
cd "<SKILL_BASE_DIR>" && yak script/ssti.yak --httpflow-id <FLOW_ID>

# - 如果路径包含 xpath 或参数名包含 user/search 等
cd "<SKILL_BASE_DIR>" && yak script/xpath_injection.yak --httpflow-id <FLOW_ID>

# 3. 通用/响应类检测（可选，按需执行）
cd "<SKILL_BASE_DIR>" && yak script/sensitive_info_leak.yak --httpflow-id <FLOW_ID>
cd "<SKILL_BASE_DIR>" && yak script/headers.yak --httpflow-id <FLOW_ID>        # 安全头与 Server 泄露
cd "<SKILL_BASE_DIR>" && yak script/cors.yak --httpflow-id <FLOW_ID>           # CORS 配置
cd "<SKILL_BASE_DIR>" && yak script/sensitivefile.yak --httpflow-id <FLOW_ID> # 敏感文件探测
# 路径像目录（以 / 结尾或含目录名）时
cd "<SKILL_BASE_DIR>" && yak script/dirlist.yak --httpflow-id <FLOW_ID>
# 写操作（POST/PUT/DELETE）时检测 CSRF Token
cd "<SKILL_BASE_DIR>" && yak script/csrf.yak --httpflow-id <FLOW_ID>
# 参数含 redirect/url/location 等时检测 CRLF 注入
cd "<SKILL_BASE_DIR>" && yak script/crlf.yak --httpflow-id <FLOW_ID>
```

**执行要求**:
- 对每个 Flow ID，依次执行**至少3个核心脚本**（xss, ssrf, open_redirect）
- 根据请求特征**智能选择**其他适用脚本
- 如果脚本返回"未发现可测试的有效参数"，跳过并继续
- **收集所有漏洞结果**，不仅仅是 XSS

---

### **阶段5：弱口令爆破** 🔑（tools/port_scan/brute.yak）

使用本技能目录下的 **tools/port_scan/brute.yak** 对阶段0 发现的非 Web 服务（SSH、MySQL、Redis、FTP、RDP、MongoDB、PostgreSQL、SMB 等）做弱口令检测。

**命令**（先 cd 到本技能目录）:
```bash
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/brute.yak --targets "<IP:端口:服务>,<IP:端口:服务>,..."
```
**格式**：`IP:端口:服务`，多个用逗号分隔。支持服务：`ssh`、`mysql`、`redis`、`ftp`、`mongodb`、`postgres`、`smb`、`rdp` 等。

**示例**：若阶段0 发现 22(SSH)、3306(MySQL)、6379(Redis)：
```bash
cd "<SKILL_BASE_DIR>" && yak tools/port_scan/brute.yak --targets "192.168.3.24:22:ssh,192.168.3.24:3306:mysql,192.168.3.24:6379:redis"
```

**执行要求**:
- 根据阶段0 的开放端口与服务类型，构造 `--targets` 列表（仅对支持爆破的服务执行）
- 执行命令并**等待结果**
- 将弱口令结果写入最终报告的「弱口令检测」小节
- **阶段5 为全流程最后一步**，完成后输出最终报告

---

## 最终报告格式

完成所有阶段后，**必须**输出以下格式的报告：

```markdown
### 🏁 渗透测试报告: <TARGET_URL>

#### 0. 🔍 端口与服务发现（scan_tcp_port.yak）
- **开放端口**: [从阶段0提取，如 80, 443, 8081, 22, 3306]
- **识别服务**: [Web 服务 + 非 Web 服务，如 HTTP、Apache/PHP、SSH、MySQL]

#### 0b～0d. 🛡 POC 漏洞检测（query_service_fingerprint → query_plugin_by_fp → call_yak_plugin）
- **Web 指纹**: [端口:指纹，如 80:ThinkPHP, 8081:Tomcat]
- **POC 检测结果**: [若有] 列出 call_yak_plugin 发现的漏洞；若无则写「未检测到已知 POC 漏洞」

#### 1. 🏗 架构简报（web_tech_analyzer）
- **Tech Stack**: [从阶段1提取]

#### 2. 🕷 爬虫摘要
- **Total Requests**: [N]
- **Attack Surface**: 发现了 [N] 个可疑动态接口

#### 3. 🛡 Web 漏洞脚本验证结果（xss/ssrf 等）
**只列已发现的漏洞，未发现的不写入表格。**
| 漏洞类型 | 目标参数/路径 | 状态 | Flow ID |
| :--- | :--- | :--- | :--- |
| XSS | `message` | 🔴 **Confirmed** | 6677 |
| SSRF | `url` | 🔴 **Confirmed** | 6678 |
...

**严重程度统计**: 🔴 高危 / 🟡 中危（仅统计已发现项）

#### 4. 🔑 弱口令检测（brute.yak）
**只列爆破成功的，未破解的不写入表格。**
| 服务 | 账号 | 结果 |
| :--- | :--- | :--- |
| SSH | root / ****** | 🔴 爆破成功 |

#### 5. 💡 修复建议
- [针对 POC 漏洞、Web 漏洞、弱口令的针对性修复建议]
```

**报告输出为 .md 文件并告知路径**：
- 完成所有阶段后，**必须**将上述格式的完整报告写入一个 **.md 文件**，并**在回复中明确给出该文件的完整路径**，方便用户查找。
- **保存路径**：`<SKILL_BASE_DIR>/reports/` 目录下（若不存在请先创建）。文件名建议：`pentest_<目标主机或域名>_<日期时间>.md`，例如 `pentest_192.168.3.24_20250130_143022.md`，避免多次扫描覆盖。
- **回复中必须包含**：在输出报告摘要或结尾处写一句 **「报告已保存至: \<完整绝对路径\>」**，例如：`报告已保存至: /Users/xxx/evil-opencode-main/.opencode/skill/auto-pentest/reports/pentest_192.168.3.24_20250130_143022.md`

---

## ⚠️ 重要约束

1. **不要问用户"是否继续"** - 看到触发关键词就直接执行
2. **路径** - 所有阶段均使用 **SKILL_BASE_DIR**（本技能 Base directory），先 `cd "<SKILL_BASE_DIR>"` 再执行 `yak tools/port_scan/...` 或 `./tools/...` 或 `yak tools/...`。不要用相对路径 `.opencode/skill/...`（易报 no such file or directory）。
3. **必须连续执行全部阶段** - 阶段0 → 0b → 0c → 0d → 1 → 2 → 3 → 4 → 5，不得在阶段0 后停止。每一阶段命令结束后，**在同一轮回复中**马上发起下一阶段。
4. **tools/port_scan 脚本必须全部用到** - 阶段0 用 scan_tcp_port.yak；阶段0b 用 query_service_fingerprint.yak（仅 HTTP/HTTPS 端口）；阶段0c 用 query_plugin_by_fp.yak；阶段0d 用 call_yak_plugin.yak（每个有 POC 的端口一次）；阶段5 用 brute.yak。若 0b 无 Web 指纹则跳过 0c、0d。
5. **多端口 Web 必须全覆盖** - 若阶段0 发现多个 Web 端口，对**每个** `http(s)://<TARGET_HOST>:<port>` 都要分别执行阶段1～4。
6. **不要输出中间日志** - 只输出每个阶段的简短摘要
7. **漏洞结果只输出已发现的** - 汇总或展示漏洞检测结果时，**只输出/只列入「已发现」的漏洞**（Confirmed、Suspected、爆破成功等）；**未发现的不要输出**，不要在表格或列表中列出「未发现」「Safe」「安全」等行，避免刷屏。
8. **必须等待每个命令完成** - 不要并行执行阶段
9. **如果某个命令失败** - 立即停止并告诉用户"阶段N失败，原因：XXX"
10. **报告输出为 .md 并给出路径** - 最终报告必须写入 `<SKILL_BASE_DIR>/reports/` 下的 .md 文件，并在回复中明确写出「报告已保存至: \<完整路径\>」，方便用户查找。

---

## 💬 示例对话

**用户**: "全流程测试 http://192.168.3.24:8081/vul/xss/xss_reflected_get.php"

**AI 应该做的**:
1. 用 skill 工具加载本 skill，拿到 **Base directory**（即 SKILL_BASE_DIR）。后续所有命令均先 `cd "<SKILL_BASE_DIR>"`，再执行 `yak tools/port_scan/...` 或 `./tools/...` 或 `yak tools/...`。
2. 从 URL 解析 **TARGET_HOST**=192.168.3.24，**TARGET_BASE_URL**= `http://192.168.3.24:8081`。立即执行**阶段0**：`cd "<SKILL_BASE_DIR>" && yak tools/port_scan/scan_tcp_port.yak --hosts 192.168.3.24 --ports 21,22,80,443,3306,6379,8080,8081,... --web`
3. **阶段0b**：对 Web 端口执行 `yak tools/port_scan/query_service_fingerprint.yak --target 192.168.3.24 --ports 80,8081`，记录 端口:指纹。
4. **阶段0c**：`yak tools/port_scan/query_plugin_by_fp.yak --fingerprints "80:xxx,8081:xxx"`，得到 POC 插件列表。
5. **阶段0d**：对每个有 POC 的端口执行 `yak tools/port_scan/call_yak_plugin.yak --names "插件1,插件2" --url "http://192.168.3.24:80"`（同一 URL 所有插件一次传入）。
6. **阶段1～4**：对每个 Web 的 TARGET_BASE_URL 依次执行 web_tech_analyzer、爬虫、筛选、漏洞脚本。
7. **阶段5**：`cd "<SKILL_BASE_DIR>" && yak tools/port_scan/brute.yak --targets "192.168.3.24:22:ssh,192.168.3.24:3306:mysql,..."`（根据阶段0 发现的非 Web 服务构造）。
8. 将报告按上述格式整理后，**写入 .md 文件**到 `<SKILL_BASE_DIR>/reports/` 下，文件名如 `pentest_192.168.3.24_20250130_143022.md`，并在回复中写明 **「报告已保存至: \<完整路径\>」**，方便用户查找。

**AI 不应该做的**:
- ❌ 不使用本技能 tools/port_scan 下的脚本（scan_tcp_port、query_service_fingerprint、query_plugin_by_fp、call_yak_plugin、brute）而只用 yak scan-service 或口头描述
- ❌ 使用相对路径 `cd .opencode/skill/...` 而不使用 SKILL_BASE_DIR 绝对路径
- ❌ 在阶段0 完成后就停止，不执行 0b～0d、1～5
- ❌ 只对用户给出的那一个 URL 跑后续流程，而忽略其他 Web 端口
- ❌ 对同一 URL 的 call_yak_plugin 循环多次调用（应一次性传入所有插件名）
- ❌ 在漏洞结果表格或汇总中列出「未发现」「Safe」「安全」等行（只输出已发现的漏洞/弱口令）
- ❌ 只输出报告内容而不写入 .md 文件，或不给出「报告已保存至: \<路径\>」方便用户查找