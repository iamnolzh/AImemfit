__DESC__ = "检测弱密码登录漏洞"
__VERBOSE_NAME__ = "弱密码检测"
__KEYWORDS__ = "weak-password,brute-force,authentication"

// 配置项
debug = true
threads = 3

// CLI 参数定义
flowIDStr = cli.String(
    "httpflow-id", 
    cli.setVerboseName("HTTPFlowID"), 
    cli.setHelp("History 中的 HTTPFlow ID"), 
    cli.setRequired(true), 
)
cli.check()

// 辅助输出
aiOut = msg => { 
    try { 
        yakit.AIOutput(msg) 
    } catch { 
        println(msg) 
    }
}

// 常用弱密码
weakPasswords = [
    "admin", "password", "123456", "admin123", 
    "root", "test", "guest", "12345678",
]

// 常用用户名
commonUsernames = [
    "admin", "root", "test", "user",
]

// 检查登录成功
checkLoginSuccess = func(responseRaw) {
    if responseRaw == nil { return false }
    
    r = string(responseRaw)
    
    // 失败特征优先
    failKeywords = ["login", "error", "failed", "incorrect", "invalid", "登录失败", "错误"]
    for _, keyword = range failKeywords {
        if str.Contains(str.ToLower(r), keyword) {
            return false
        }
    }
    
    // 成功特征
    successKeywords = ["success", "welcome", "dashboard", "home", "index", "登录成功", "欢迎"]
    for _, keyword = range successKeywords {
        if str.Contains(str.ToLower(r), keyword) {
            return true
        }
    }
    
    // 检查302跳转
    if str.Contains(r, "Location:") {
        lines = str.Split(r, "\n")
        for _, line = range lines {
            if str.HasPrefix(line, "Location:") {
                location = str.ToLower(str.Trim(line[9:], " \r"))
                // 跳转到登录页=失败
                if str.Contains(location, "login") || str.Contains(location, "signin") || str.Contains(location, "auth") {
                    return false
                }
                // 跳转到其他页面=成功
                return true
            }
        }
    }
    
    return false
}

// 主程序
flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow查询失败: 未找到ID %v", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空")
    return
}

// 判断是否为POST请求
if !str.Contains(string(reqBytes), "POST") {
    aiOut("非POST请求,跳过弱密码检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

aiOut(sprintf("开始弱密码检测 (Target: %s)...", flow.Url))

// 获取参数
allParams = freq.GetCommonParams()
usernameParam = nil
passwordParam = nil

for _, param = range allParams {
    paramName = str.ToLower(param.Name())
    
    // 排除token参数
    if str.Contains(paramName, "token") || str.Contains(paramName, "csrf") {
        continue
    }
    
    // 识别用户名参数
    if paramName == "username" || paramName == "user" || paramName == "name" || paramName == "account" {
        usernameParam = param
    }
    
    // 识别密码参数
    if paramName == "password" || paramName == "pass" || paramName == "pwd" {
        passwordParam = param
    }
}

if usernameParam == nil || passwordParam == nil {
    aiOut("未识别到用户名/密码参数")
    return
}

aiOut(sprintf("识别到参数: %s, %s", usernameParam.Name(), passwordParam.Name()))

// 弱密码爆破
findings = []
wg = sync.NewSizedWaitGroup(threads)

// 检测是否有Token参数
tokenParam = nil
for _, param = range allParams {
    paramName = str.ToLower(param.Name())
    if str.Contains(paramName, "token") || str.Contains(paramName, "csrf") {
        tokenParam = param
        aiOut(sprintf("检测到Token参数: %s", param.Name()))
        break
    }
}

// Token获取函数
getNewToken = func() {
    if tokenParam == nil { return "" }
    
    // GET登录页获取新token
    getFreq, err2 := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
    if err2 != nil { return "" }
    
    getFreq = getFreq.FuzzMethod("GET").FuzzPostRaw("")
    getRes, err3 := getFreq.ExecFirst()
    if err3 != nil || getRes == nil { return "" }
    
    body = string(getRes.ResponseRaw)
    
    // 方法1: 简单字符串查找（最可靠）
    // 查找：name="user_token" ... value="token值"
    tokenNamePattern = sprintf(`name="%s"`, tokenParam.Name())
    idx = str.Index(body, tokenNamePattern)
    if idx > 0 {
        // 从name位置开始向后查找200个字符内的value
        substr = body[idx:idx+200]
        valuePattern = `value="([a-zA-Z0-9]+)"`
        matched = re.FindSubmatchAll(substr, valuePattern)
        if len(matched) > 0 && len(matched[0]) > 1 {
            token = matched[0][1]
            if debug { aiOut(sprintf("提取到Token: %s", token[:min(20, len(token))]+"...")) }
            return token
        }
    }
    
    // 方法2: 完整正则（支持单引号和双引号）
    pattern = sprintf(`name=['"]%s['"][\s\S]{0,200}?value=['"]([a-zA-Z0-9]+)['"]`, tokenParam.Name())
    matched2 = re.FindSubmatchAll(body, pattern)
    if len(matched2) > 0 && len(matched2[0]) > 1 {
        return matched2[0][1]
    }
    
    return ""
}

for _, username = range commonUsernames {
    for _, password = range weakPasswords {
        // 捕获循环变量
        username := username
        password := password
        
        wg.Add()
        go func() {
            defer wg.Done()
            
            // 如果有Token，获取新Token
            newToken = ""
            if tokenParam != nil {
                newToken = getNewToken()
                if newToken != "" {
                    if debug { aiOut(sprintf("获取到新Token: %s", newToken[:20]+"...")) }
                } else {
                    if debug { aiOut("获取Token失败，使用原Token") }
                }
            }
            
            // 每个goroutine创建独立的freq
            myFreq, err2 := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
            if err2 != nil {
                if debug { aiOut(sprintf("创建freq失败: %v", err2)) }
                return
            }
            
            // Fuzz参数
            myFreq = myFreq.FuzzPostParams(usernameParam.Name(), username)
            myFreq = myFreq.FuzzPostParams(passwordParam.Name(), password)
            
            // 如果获取到新Token，替换它
            if newToken != "" {
                myFreq = myFreq.FuzzPostParams(tokenParam.Name(), newToken)
            }
            
            res, err = myFreq.ExecFirst()
            
            if err != nil {
                if debug { aiOut(sprintf("请求失败 (%s:%s): %v", username, password, err)) }
                return
            }
            
            if res == nil { return }
            
            // 检查登录成功
            if checkLoginSuccess(res.ResponseRaw) {
                findings = append(findings, {"username": username, "password": password})
                aiOut(sprintf("✓ 发现弱密码: %s:%s", username, password))
                
                risk.NewRisk(
                    flow.Url,
                    risk.title(sprintf("Weak Password: %s:%s", username, password)),
                    risk.titleVerbose(sprintf("弱密码漏洞: %s:%s", username, password)),
                    risk.details({"username": username, "password": password, "url": flow.Url}),
                    risk.type("weak-password"),
                    risk.severity("high"),
                    risk.payload(sprintf("%s:%s", username, password)),
                    risk.request(res.RequestRaw),
                    risk.response(res.ResponseRaw),
                    risk.description(sprintf("系统存在弱密码账户: %s:%s", username, password)),
                    risk.solution("1. 强制使用强密码策略。\n2. 启用多因素认证。\n3. 限制登录尝试次数。")
                )
            }
        }()
    }
}

wg.Wait()

if len(findings) == 0 {
    aiOut("未发现弱密码")
}

aiOut(sprintf("=== 弱密码检测完成, 发现 %d 个问题 ===", len(findings)))
