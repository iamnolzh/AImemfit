__DESC__ = "检测CRLF注入漏洞"
__VERBOSE_NAME__ = "CRLF注入检测"
__KEYWORDS__ = "crlf-injection,http-response-splitting"

// 配置项
debug = false

// -------------------------------------------------------------------
// CLI 参数定义
// -------------------------------------------------------------------
flowIDStr = cli.String(
    "httpflow-id", 
    cli.setVerboseName("HTTPFlowID"), 
    cli.setHelp("History 中的 HTTPFlow ID,用于获取请求/响应包内容"), 
    cli.setRequired(true), 
)
cli.check()

// 辅助输出函数
aiOut = msg => { 
    try {
        yakit.AIOutput(msg) 
    } catch {
        println(msg)
    }
}

// -------------------------------------------------------------------
// 核心数据结构
// -------------------------------------------------------------------

// CRLF注入Payload
crlfPayloads = [
    "%0d%0aX-Injected-Header: test",
    "%0aX-Injected-Header: test",
    "%0d%0a%0d%0a<script>alert(1)</script>",
    "\r\nX-Injected-Header: test",
    "\nX-Injected-Header: test",
]

// -------------------------------------------------------------------
// 核心逻辑
// -------------------------------------------------------------------

// 检查CRLF注入
checkCRLF = func(responseRaw) {
    if responseRaw == nil { return false }
    
    r = string(responseRaw)
    
    // 检查注入的header
    if str.Contains(r, "X-Injected-Header: test") {
        return true
    }
    
    // 检查注入的内容
    if str.Contains(r, "<script>alert(1)</script>") {
        return true
    }
    
    return false
}

// -------------------------------------------------------------------
// 主程序入口
// -------------------------------------------------------------------

flowID = parseInt(flowIDStr)
flowsChan := db.QueryHTTPFlowsByID(flowID)
flow = nil
for f := range flowsChan {
    flow = f
    break
}

if flow == nil {
    aiOut(sprintf("HTTPFlow 查询失败: 未找到 ID 为 %v 的请求", flowID))
    return
}

reqBytes = flow.GetRequest()
if reqBytes == nil { reqBytes = []byte(flow.Request) }
if reqBytes == nil || len(reqBytes) == 0 {
    aiOut("请求包为空,无法检测")
    return
}

isHttps = flow.IsHTTPS
freq, err := fuzz.HTTPRequest(reqBytes, fuzz.https(isHttps))
if err != nil {
    aiOut(sprintf("解析请求失败: %v", err))
    return
}

// 获取参数
allParams = freq.GetCommonParams()
if len(allParams) == 0 {
    aiOut("未发现参数,跳过CRLF检测")
    return
}

aiOut(sprintf("开始CRLF注入检测 (Target: %s)...", flow.Url))

// 遍历参数和Payload
findings = []
for _, param = range allParams {
    for _, payload = range crlfPayloads {
        fuzzReq = param.Fuzz(payload)
        res, err = fuzzReq.ExecFirst()
        
        if err != nil {
            if debug { aiOut(sprintf("请求失败 (Param: %s): %v", param.Name(), err)) }
            continue
        }
        
        if res == nil { continue }
        
        // 检查CRLF注入
        if checkCRLF(res.ResponseRaw) {
            findings = append(findings, {"param": param.Name(), "payload": payload})
            aiOut(sprintf("✓ 发现CRLF注入: 参数=%s, Payload=%s", param.Name(), payload))
            
            risk.NewRisk(
                flow.Url,
                risk.title(sprintf("CRLF Injection: %s", param.Name())),
                risk.titleVerbose(sprintf("CRLF注入漏洞: %s", param.Name())),
                risk.details({"param": param.Name(), "payload": payload, "url": flow.Url}),
                risk.type("crlf-injection"),
                risk.severity("high"),
                risk.payload(payload),
                risk.request(res.RequestRaw),
                risk.response(res.ResponseRaw),
                risk.description(sprintf("参数 %s 存在CRLF注入漏洞，可能导致HTTP响应拆分攻击。", param.Name())),
                risk.solution("1. 严格过滤 \\r 和 \\n 字符。\n2. 使用安全的HTTP库。\n3. 验证所有输入。")
            )
            
            break // 找到一个就够了
        }
    }
}

if len(findings) == 0 {
    aiOut("未发现CRLF注入")
}

aiOut(sprintf("=== CRLF注入检测完成, 发现 %d 个问题 ===", len(findings)))
